---
title: "5. Data Visualisation"
author: "Ricardo"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float: yes
    pandoc_args: ["--lua-filter=color-text.lua"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load the packages
library(tidyverse)
library(tibble)
library(readr)
library(ggplot2)
library(dplyr)
```

```{cat, engine.opts = list(file = "color-text.lua")}
Span = function(el)
  color = el.attributes['color']
  -- if no color attribute, return unchange
  if color == nil then return el end
  
  -- transform to <span style="color: red;"></span>
  if FORMAT:match 'html' then
    -- remove color attributes
    el.attributes['color'] = nil
    -- use style attribute instead
    el.attributes['style'] = 'color: ' .. color .. ';'
    -- return full span element
    return el
  elseif FORMAT:match 'latex' then
    -- remove color attributes
    el.attributes['color'] = nil
    -- encapsulate in latex code
    table.insert(
      el.content, 1,
      pandoc.RawInline('latex', '\\textcolor{'..color..'}{')
    )
    table.insert(
      el.content,
      pandoc.RawInline('latex', '}')
    )
    -- returns only span content
    return el.content
  else
    -- for other format return unchanged
    return el
  end
end
```

# **1. Visualisation Data with ggplot2**

## Introduction

In this lesson, we'll learn how to visualize data to identify patterns and uncover insights. A single graph can tell us much more than a dataset in the form of a tibble. So, in this lesson, we'll explore the principles of data visualization, learn to visualize data trends using R, and experiment with different types of data visualizations:

To get the most out of this lesson, you'll need be comfortable with programming in R.

We'll use the `ggplot2` package to create our visualizations. This package is popular because of its intuitive syntax and speed for developing high-quality visualizations. We'll briefly cover how `ggplot2` works, and then we'll explore other types of visualizations in-depth.

Here are a few takeaways you can expect by the end of this lesson:

-   The basics of `ggplot2` for data visualization
-   How to create line graphs to visualize changes over time
-   How visualizing data can help you understand trends Let's start by importing the data into R. It's stored as a file named `life_expec.csv.`

Use `read_csv()`to read the "life_expec.csv" file into R. Save it as a DataFrame named `life_expec.`

```{r}
life_expec <- read_csv("life_expec.csv")
glimpse(life_expec)
dim(life_expec) # the dataset contains 1035 rows and 5 columns
head(life_expec, 10)
```

## Introducing the Data

The [National Centre for Health Statistics](https://www.cdc.gov/nchs/index.htm) has been tracking mortality trends in the United States since 1900. They've compiled data on the life expectancy of U.S. citizens by race and sex. On the previous screen, we loaded in this data into the `life_expec` variable.

Here are the first ten rows of the `life_expec` DataFrame:

Each column in the DataFrame contains a variable about the population of individuals born each year. Here's an explanation of each variable:

-   `Year`: the year of birth
-   `Race`: the races represented in the measured population
-   `Sex`: the sex of the measured population
-   `Avg_Life_Expec`: the average life expectancy, in years, at birth of people born in a given year
-   `Age_Adj_Death_Rate`: the [age adjusted death rate](https://health.mo.gov/data/mica/CDP_MICA/AARate.html) of people born in a given year--- the age adjusted death rate is a metric that adjusts death rate for populations' age distributions to make population comparisons equitable

Since collection of this data began in 1900, we have over 100 years of data that we can use to study changes in average U.S. life expectancy over time.

As health care has improved, people are living longer. As you scroll through the data, you'll see that life expectancy has generally increased and death rate has decreased over time.

While scanning the data may give you some sense of general patterns, it's not a scalable solution. If you had much more data, it would be harder to keep track of what's happening. This is an even bigger problem if you're trying to look for trends in data that aren't time-based. [Looking for trends in the data is better suited to data visualization. For example, we can display trends on a single plot. Exploring data visually is usually one of the first steps data scientists take when working with new data.]{color="red"}

## The Grammar of Graphics

Before we begin our first visualization, we should explore how `ggplot2` creates data visualizations. The `gg` in `ggplot2` stands for `grammar of graphics`, which refers to a system for data visualization first described by Leland Wilkinson. Hadley Wickham, a chief data scientist at RStudio, developed the `ggplot2` package to allow users to create plots based on this system. The `ggplot2` package creates a principled method to develop plots that are easy to replicate and code.

*This grammar of graphics system takes a plot, like the line graph below and breaks it down into different layers.*

![](https://s3.amazonaws.com/dq-content/273/plot_example.svg)\

A user combines different layers to create different plots. For this example, there are four different layers:

1.  The data used to create the plot:\
    ![](https://s3.amazonaws.com/dq-content/273/data.svg)\
2.  The axes used in the plot:\
    ![](https://s3.amazonaws.com/dq-content/273/coord_sys.svg)\
3.  The geometric shapes used to visualize the data --- in this case, a line:\
    ![](https://s3.amazonaws.com/dq-content/273/geoms.svg)\
4.  Any labels or annotations that help a reader understand what they're seeing on the plot\
    ![](https://s3.amazonaws.com/dq-content/273/annotations.svg)\
5.  Combining all of these layers creates a plot that shows the relationship between one variable `X` and another variable `Y.`\
    ![](https://s3.amazonaws.com/dq-content/273/complete_line_graph.svg)\

Instead of just inspecting the data, we can see how the value of `Y` changes as the value of `X` changes. In this case, there seems to be a negative relationship between the two. As `X` increases in value, `Y` decreases in value. Since we're looking at life expectancy data, `X` might be time, while `Y` might be life expectancy.

To begin our first visualization, we'll start with the first layer: the data. To begin making a plot, we will take the `life_expec` data and pipe (`%>%`) it into the `ggplot()` function.

```{r}
life_expec  %>% 
  ggplot()
```

The code above starts the process of creating a plot based on the `life_expec` data. At this stage, **the graphic you'll see is an empty plot: we haven't specified what variables to use or what shapes to visualize the data.** As we move through the lesson, we'll add more layers.

Use the `ggplot()` function to create the first layer of your plot using the `life_expec` DataFrame.

## Specifying Variables To Axes

When graphing two-dimensional data, `ggplot2` uses the Cartesian coordinate system by default. This means that your graphs have two axes:

![](https://s3.amazonaws.com/dq-content/273/two_axes.svg)\
We refer to the horizontal axis as the "x-axis" and the vertical axis as the "y-axis."

The first layer you'll add is the axes. Now that the plot knows it needs to visualize the `life_expec` data, we need to describe which columns to use for each of the axes. To define the variables you want for each axis, we need to use the `aes()` function. `aes` is short for "aesthetics." Here is an example use case using a fake dataset called `data`, which has columns `variable_1` and `variable_2`:

```{r}
# data  %>% ggplot(aes(x = variable_1, y = variable_2)) 
```

The code above specifies that we should use `variable_1` for the x-axis and `variable_2` for the y-axis.[Notice that `variable_1` and `variable_2` aren't in quotation marks. As with the other `tidyverse` libraries, we don't need to quote the column names inside the functions.]{color="red"} Furthermore, we don't need to assign the variables you will be visualizing to `x` and `y` arguments within `aes()`, but we highly recommend you do so to keep your code as readable as possible.

We may ask, "How do you know which axis to use for which variable?" This mostly depends on the question we're trying to answer with the plot. Often, these questions take on the form "As the X variable changes, what happens to the `Y` variable?" or "What is the relationship between the X and `Y` variables?" Furthermore, `X` is something we can control or measure, and `Y` is something that we think changes in response to changes in `X.` In the scientific community, there are specific names for these variables:

-   The variable that we can "change" or "control" is the independent variable. By convention, we assign this variable to the horizontal x-axis.
-   The variable that changes depending on the independent variable is the dependent variable. By convention, we assign this variable to the vertical y-axis.

In the case of our `life_expec` data, we want to see how life expectancy has changed over time. Therefore, the `Year` variable represents time and is the independent variable. Consequently, the `Avg_Life_Expec` changes as time progresses, so we would consider it the dependent variable.

![](https://dq-content.s3.amazonaws.com/273/life_expec_axes.svg)\
Let's add a layer to your graph to map the `Avg_Life_Expec` and `Year` variables to a coordinate system.

1.  Add an `aes()` layer to your graph specifying `Avg_Life_Expec` as the dependent variable and `Year` as the independent variable.

-   You don't need to assign the variables you'll be visualizing to `x` and `y` within `aes()`, but we highly recommend you do so to avoid confusing them.

```{r}
life_expec %>% ggplot(aes( x = Year, y = Avg_Life_Expec))
```

## Adding Geometric Objects to Visualize Data Points

With these two layers in place, we need to add geometric symbols to the graph to actually represent each of the individual data points. To add a line representing the relationship between the `Year` and `Avg_Life_Expec` variables to your graph, you'll use the `geom_line()` function.

```{r}
# data  %>% 
#   ggplot(aes(x = variable_1, y = variable_2)) +
#   geom_line()
```

There are a few important details in the code above. First, notice how we added the new layer containing the line shape to the graph using a `+` at the end. Once we have started creating a plot using `ggplot()`, we add more layers onto it using +. This will be true no matter what kind of layer you're adding to the plot. [While the data is a layer in the graph, we must pipe it into the `ggplot()` function to start the process of creating a plot; from then on, we add layers via `+`.]{color="red"}

Second, we have separated the new layer code into a new line. This isn't mandatory, but it makes your code easier to read, so your future self (and your collaborators) will thank you.

Finally, `ggplot2` uses a naming convention for each of the functions that add shapes to plots, denoted with the name `geom_*`. This makes it easy to identify which function is generating the shapes on our graph.

The line shape is just one of many choices that we have for visualizing the data. While the choice is usually ours, some shapes are better at answering certain questions than others. In this case, a line implies that there is a relationship between each of the data points. Since our x-axis is time, a line graph illustrates changes over time. As we progress through other lessons, we'll learn other shapes (geoms) and their typical use cases.

Let's add a layer to your graph to allow you to visualize the data.

1.  Add a layer to your graph to illustrate the relationship between `Year` and `Avg_Life_Expec.`

```{r}
life_expec %>% ggplot(aes( x = Year, y = Avg_Life_Expec)) + geom_line()
```

## Data Preprocessing for Visualization

The graph needs more work. `ggplot2` can't determine the difference between a good and a bad visualization; it only executes the code that we give it. The reason that our graph looks the way it does is because of the data itself. Let's take a look at a single year from the `life_expec` data to see what's happening:

```{r}
life_expec %>%
  filter(Year == 2000)
```

For the year 2000, there are nine data points: ![](https://s3.amazonaws.com/dq-content/273/select_average.svg)\

This filtered data tells us that there are multiple life expectancy points associated with one year. Each of these points represents a life expectancy of a particular group. In order to clean up the visualization, we will need to be more specific with our question. [We want to get a sense for the change over time of life expectancy for the entire U.S. population, so we should use the data for all races and both sexes to create the line graph.]{color="blue"}

We can use the `filter()` function from the `dplyr` package to select a subset of a data based on values of one or more variables. If we want to do some data processing before piping it into the plot, we can just add the `filter()` function directly into the pipeline itself, as demonstrated in the following code:

```{r}
# data %>% 
#   filter(variable_1 == "value we want to keep") %>% 
#   ggplot(aes(x = variable_1, y = variable_2)) +
#   geom_line()
```

You could also assign the filtered dataset to its own variable and then pipe that new dataset into `ggplot.` For our exercise, we'll create a new variable. Let's create a new line graph containing only average life expectancy data for the entire U.S. population.

1.  Create a new tibble, `life_expec_filter`, containing only rows for which the `Race` variable has the value "All Races," and the `Sex` variable has the value "Both Sexes."

2.  Create a line graph that displays the relationship between `Avg_Life_Expec` and `Year.`

```{r}
life_expec_filter <- life_expec %>% 
  filter(
    Race == "All Races",
    Sex == "Both Sexes"
  )

life_expec_filter %>%  ggplot(aes( x = Year, y = Avg_Life_Expec)) + geom_line()
```

## Making Our Graph More Descriptive

The above visualization of the relationship between `Avg_Life_Expec` and `Year` helps us quickly detect some interesting patterns in the data:

-   Generally, average life expectancy of the U.S. population has been increasing over time.
-   Before the 1950s, life expectancy fluctuated substantially from year to year.
-   In the 1920s, life expectancy dropped dramatically, and then it increased again.

However, there are some details that still need some improvement. As a data scientist, you must always consider the audience for your visualization. Is the visualization something for you to reference later? Will others be seeing it? In all cases, it is crucial that all of your visualizations are self-contained. This means that if we received only the graph, with no additional information, would we still be able to understand what the graph is trying to portray?

In its current state, the label for the y-axis still contains the column name `Avg_Life_Expec.` Unless you knew about the data, it would be hard to discern what this string means. Furthermore, there is no title that summarizes the graph for us. These details are important in any plot, so we'll add this layer on this screen. You can add these elements to your graph using the `labs()` function (short for "labels"). Here is an example:

```{r}
# data %>% 
#   ggplot(aes(x = variable_1, y = variable_2)) +
#   geom_line() +
#   labs(
#     title = "Title of Graph",
#     x = "x-axis variable",
#     y = "y-axis variable"
#   )
```

A good graph title should give your audience information about the data to help them fully understand the visual. [For the line graph you're working on, an example of an informative title would be **"United States Life Expectancy: 100 Years of Change"**.]{color="red"} This title communicates the goal of the visualization, which is to understand U.S. life expectancy over time.

Similarly, it's important to make sure that someone who looks at your graph can understand the data being represented. In the case of the graph you've been working on, it may be unclear what that y-axis label, `Avg_Life_Expec`, refers to. To specify new labels for the x- or y-axis, use the syntax `x =` or `y =` within `labs()`.

When you assign axis labels, it's good practice to be very descriptive. In the case of the y-axis label on the line graph you're working on, an example of a descriptive axis label is "Average Life Expectancy (years)". Notice that the label includes the units, "years," which express the data. Including units in your axis labels is important --- it clearly communicates the type of data you used to create the graph.

Let's add a descriptive title and axis labels to your line graph.

1.  Give your graph a descriptive title that communicates the goal of the visualization: "United States Life Expectancy: 100 Years of Change"
2.  Give the y-axis this label: "Average Life Expectancy (Years)"

```{r}
life_expec_filter %>% 
  ggplot(aes( x = Year, y = Avg_Life_Expec)) +
  geom_line() +
  labs(
    title = "United States Life Expectancy: 100 years of Change",
    y = "Average Life Expectancy (Years)",
    x = "Year"
  )
  
```

## Refining Graph Aesthetics

Our line graph is now clear and descriptive --- we can study it to understand patterns in U.S. life expectancy data.

Before we conclude this lesson, let's consider a few details about the overall look of the graph itself. You may have noticed that the background of the graph is gray, even though we haven't designated this anywhere in our code. By default, `ggplot2` sets some default options. If we wanted to specify these colors ourselves, we can look to the `theme()` function.

The gray background is a bit distracting, so we should change it to white. This allows us to focus on the line itself. Let's simplify the graph background to help the line representation of the data stand out.

Within the `theme()` layer, you'll use the argument `panel.background = element_rect("background_color")` to specify the color of the background rectangle (which is what "rect" stands for). A string with an actual color should replace the string "background_color."

```{r}
# data %>% 
#   ggplot(aes(x = variable_1, y = variable_2)) +
#     geom_line() +
#     labs(
#       title = "Title of Graph", 
#       x = "new x label", 
#       y = "new y label") + 
#     theme(
#       panel.background = element_rect(fill = "background_color")
#     )
```

There are many things we can change using the`theme()` function, which you can explore in the documentation. Let's change the background of your line graph to make it less distracting.

1.  Change the background color of your line graph to white.

```{r}
life_expec_filter %>% 
  ggplot(aes(x = Year, y = Avg_Life_Expec)) +
  geom_line() +
  labs(
    title = "United States Life Expectancy: 100 years of Change",
    y = "Average Life Expectancy (Years)",
    x = "Year") +
  theme(
    panel.background = element_rect(fill = "white")
  )
```

# **2. Visualising Data Distribution**

## Introduction

In the last lesson, we learned about the `ggplot2` package and how to use it to create our first graph. `ggplot2` takes visualizations and dissects it into "layers". We as programmers specify what we want for each layer, and they are combined to produce a polished graph. These layers include the data, the axes, and the geometric shapes needed to visualize the data and any labels that help explain the graph itself.

In this lesson, we'll look at a set of graph types that help us understand how data is distributed. When we say "data distribution," we are referring to questions about what kinds of values are in our data and how frequently they appear in our data. We start with data distributions because it's important to understand your data before you move forward with more complex analyses.

To aid in our understanding of these distribution graphs, we'll be working with movie review data!

![](https://s3.amazonaws.com/dq-content/review_sites_screenshots.png)

## Introducing the Data and Problem Statement

When Hollywood releases new movies, Metacritic, Fandango, Rotten Tomatoes, and IMDB use different systems to calculate ratings based on the reviews by movie critics and consumers.

Which of these sites should you consult when deciding whether to see a movie? Since each site uses a different system to create the reviews, it's possible that the same movie will be reviewed differently. If we want to consult one of these sites for a review, we should understand how each of different sites' movie reviews compare to one another. If we know a site biased more towards positive or negative reviews, we can use this information to mentally correct for any reviews we might see.

For example, Fandango has been suspected of releasing inflated ratings to increase ticket sales. After they found that some films that garnered poor ratings elsewhere were rated highly on Fandango, analysts from FiveThirtyEight investigated and published an article about bias in movie ratings.

To conduct the investigation, the team compiled data for 147 films from 2015 with reviews from movie critics and consumers.

In this lesson, you'll use this data and `ggplot2` to visualize reviews from Metacritic, Fandango, Rotten Tomatoes, and IMDB to get a sense for differences in the way the four sites compute movie ratings.

We have made a subset of the data available for you to work with in this lesson in a file named `"movie_reviews.csv"`. The file contains three columns:

-   `Film`: Movie name and release year.
-   `Rating_Site`: The site that calculated the rating (`Rotten_Tomatoes`, `Metacritic`, `IMDB`, or `Fandango`).
-   `Rating`: The assigned movie rating.

Let's start by importing the data into R.

1.  Import the `"movie_reviews.csv"` file into R and save it as a tibble named `reviews.`

```{r}
reviews <- read_csv("movie_reviews.csv")
head(reviews, 10)
glimpse(reviews)
```

## Comparing Averages Among Rating Sites

Each film in the reviews data contains four ratings, one from each movie rating site

1.  Use `group_by()` to group the `reviews` dataframe by `Rating_Site.`
2.  Use `summarize()` to calculate the average `Rating` for each `Rating_Site.` Save the summary tibble as `review_avgs.` Assign the average to the column `avg.`

```{r}
review_avgs <- reviews %>%
  group_by(Rating_Site) %>% 
  summarise(
    avg = mean(Rating)
    )
review_avgs
```

## Visualizing Groups Differences Using Bar Graphs

In the last lesson, we were interested in understanding how life expectancy changed over time, you learned to create line graphs. Line graphs are useful for depicting changes in a dependent variable (i.e. life expectancy) over the independent variable (i.e. time).

In this lesson, we are more so interested in differences between four groups: the movie review sites. Our independent variable are the sites, while our dependent variable is the average review score. In this case, a line graph wouldn't work so well here because the movie sites are four distinct entities. We don't have a good reason to try to link the average scores between them.

A better visualization would be a bar chart. Bar charts represent grouped data summaries using bars where the heights of each bar are proportional to some value we specify. We show an example bar chart below:

![](https://s3.amazonaws.com/dq-content/275/bar_chart_examp.svg)\

To create a bar chart to visualize the average ratings for each movie rating site, you would use the `review_avgs` dataframe you created when you grouped and summarized the `reviews` dataframe.

The syntax for the data and aesthetics layers you'll specify when creating a bar chart with `ggplot2` is the same as the syntax you learned when creating line graphs. You'll specify the `review_avgs` data frame as the data layer, and the `rating_site` and `avg` variables as `x` and `y`, respectively.

```{r}
review_avgs %>%
  ggplot(aes(x = Rating_Site, y = avg))
```

Since we're using a different shape to represent the data, we need to use a different function to produce it. [While `geom_line()` is used to create a line graph, `geom_col()` helps us create a bar graph:]{color="red"}

```{r}
review_avgs %>%
  ggplot(aes(x = Rating_Site, y = avg)) +
  geom_col()
```

[You may ask, "Why is the word `col` used instead of `bar` if we're creating a bar graph?" The `geom_col()` function is a close cousin to the `geom_bar()` function, which we will cover on the next screen. By default, `geom_bar()` converts the y-axis into the frequency, or number, of rows that a particular value on the x-axis appears in the data.]{color="red"}

There is a way for us to specify how to control the heights of the bars in `geom_bar()`, but the cleaner approach is to use the `geom_col()` function. With `geom_col()`, we can directly specify the heights of the individual bars in `aes()` and get the plot.

Let's practice creating a bar chart to display the differences in average movie ratings among review sites.

## Checking Row Counts With geom_bar()

On the last screen, we developed our first bar graph using the `geom_col()` function.

On this screen, we'll have a look at the `geom_bar()` function, which also creates a bar graph. By default, `geom_bar()` uses row counts automatically for the y-axis, but we needed to plot the average review score for each site instead.

Thankfully, we have a use for`geom_bar()` in this situation as well. If we wanted to take an average of a list of numbers, say 1 through 5, we would use the following formula:

$$
Average\ of\ Values  = \frac{Sum\ of\ Values}{Number\ of\ Values}
$$

which would turn into:

$$
Average\ of\ 1\ through\ 5\ = \frac{15}{5}=3
$$

One of the components that is used to calculate an average is the number of values we're trying to take an average of. If the number of values is large, it can change the average. As a check, we want to make sure that each of the sites in our data has a similar number of items. This ensures that the average review scores between sites are comparable. We'll use the `geom_bar()`function to do this.

Just as with `geom_col()`, the `geom_bar()` function is a function that adds the geometric shape layer to our plots. [Since it's already using row count for the y-axis, we only need to specify the x-axis in the `aes()` function.]{color="red"}

```{r}
reviews %>%
  ggplot(aes(x = Rating_Site)) +
  geom_bar()
```

For completeness, we will show to use `geom_bar()` in order to graph the heights of a column that specify. We need to make use of an argument called `stat` within `geom_bar()`. By designating `stat = "identity"`, `geom_bar()` will perform the same job as `geom_col()`:

```{r}
review_avgs %>%
  ggplot(aes(x = Rating_Site, y = avg)) +
  geom_bar(stat = "identity")
```

Now use this code to check the number of reviews for each site in the `reviews` data.

1.  Using the `reviews` data, create a graph that looks at how many rows are allocated to each of the sites in the `Rating_Site` column.

```{r}
reviews %>%
  ggplot(aes(x = Rating_Site)) +
  geom_bar()
```

## Using Histograms to Understand Distribution

In the last screen, we used the`geom_bar()` function to show that each of the rating sites in the data has an equal amount of rows. This means the average for each site is reasonably comparable. We saw Fandango had a slightly higher average movie rating than the other three sites, so we should pursue this observation further. Does this higher average automatically mean Fandango tends to give higher ratings?

To consider that question, let's think about what the bar chart does not show us. We have observed that Fandango's average movie rating is higher than those of the other sites, but we don't know why it's higher. An average score can be "skewed" to be higher or lower from a few extreme scores. One explanation is that Fandango tends to give all movies good ratings, or perhaps because it gave some movies average ratings and a small number of movies excellent ratings. It might even be that the other three sites give harsher reviews!

In other words, the bar chart we created does not tell us anything about the spread of the data. An average boils down the data into a single summary value that is still useful to us, but can be unhelpful in other ways. The average of a set of numbers does not tell us anything about the spread of the numbers that were used to calculate the average. For example, the values of these two variables both have an average of 5:

-   `Variable 1`: 5 5 5 5 5 4 5 5 6 5
-   `Variable 2`: 20 9 1 2 8 4 9 5 7

However, while values of `Variable 1` are distributed between 4 and 6, values of `Variable 2` are distributed between 1 and 20. The values of `Variable 2` are much more spread out than those of `Variable 1`.

We'll spend the rest of this lesson taking a more nuanced look at the movie rating data by learning about ways to visualize how values of variables are distributed, or spread.

One such type of visual is a histogram. Histograms also use bar heights to visualize values, and they are used to assess the distribution (ie spread) of a single variable in the data. For example, here is a histogram showing the distribution of all values of the `Rating` variable of the `reviews` dataframe:

![](https://s3.amazonaws.com/dq-content/275/all_values_histogram.svg)\

On the x-axis is the Rating variable. This histogram has aggregated, or "binned", values of the Rating variable into five categories:

-   0.5 - 1.5
-   1.5 - 2.5
-   2.5 - 3.5
-   3.5 - 4.5
-   4.5 - 5.5

On the y-axis is a variable that is calculated automatically when you create the histogram: `count.` The `count` variable represents the number of values of the `Rating` variable that fall into each of the five categories on the x-axis.

This histogram tells us that many values of the `Rating` variable fall into the 2.5-3.5 and 3.5-4.5 categories. Very few fall into the 0.5-1.5 and 4.5-5.5 categories.

To create a histogram in `ggplot2`, we look to the `geom_histogram()` function. Just as with `geom_bar()`, we only need to specify what variable we want to use for the x-axis. `ggplot` automatically calculates the counts for us. We have an example use below:

```{r}
reviews %>%
  ggplot(aes(x = Rating)) +
  geom_histogram(binwidth = 1)
```

Within the `geom_histogram()` layer, we've specified a number for the `binwidth` argument. The argument `binwidth = 1` specifies the size of the categories used to bin the values of the independent variable, as we can see with the 0.5-1.5 bin. More specifically, we can use two different arguments to specify the number of categories for binning the independent variable.

-   `binwidth =` allows you to specify the size of the bins, and is useful for instances, such as this example, where you want categories to span specific intervals.
-   `bins =` allows you to specify the number of bins, which can be useful to experiment with when deciding how much detail you want to use to display your data.

Changing these arguments will change the resulting shape of the histogram. We can change and experiment with these values to alter the visualization to our needs. If you don't specify any arguments within the `geom_histogram()` layer, `ggplot2` will use a default number of bins.

Let's experiment with different numbers of `bins` to display the `Rating` variable.

1.  Create a histogram to show the distribution of all values of the `Rating` variable in the `reviews` data frame.

-   Specify 30 `bins` to categorize values of the independent variable.

```{r}
reviews %>% ggplot(aes(x = Rating)) +
  geom_histogram(bins = 30)
```

## Plotting Multiple Groups Simultaneously

The graph we created in the last plot helps us visualize the spread of the `Rating` variable, but it was for the entirety of the `reviews` data. We found that Fandango had a slightly higher average review score than the other sites, so we're pursuing the reasons behind this higher score. In this case, it would be better for us to look at the distribution for each site. For example, in order to see the distribution for Fandango, we can filter the data down:

```{r}
reviews %>%
  filter(Rating_Site == "Fandango") %>% 
  ggplot(aes(x = Rating)) +
    geom_histogram(bins = 30)
```

We can use similar code to get the histograms for the other 3 sites. This results in 4 separate graphs that we may try to compare and use to answer our question. However, it would be even better if all of the different histograms were on the same plot. This would unify the axes for each of the sites and make them easier to compare visually.

We need a way to tell `ggplot` how to distinguish between the different sites in the data while keeping them on the same axes. `ggplot` enables us to do this within the `aes()` function through the `color` and `fill` arguments. We can supply a grouping variable to this argument to tell `ggplot` that it should create separate graphs for each of the groups present in this variable. We show an example use below:

```{r}
reviews %>%
  ggplot(aes(x = Rating, color = Rating_Site)) +
  geom_histogram(bins = 30)
```

This is exactly what we wanted! The `Rating_Site` column contains four unique values corresponding to the 4 movie sites, so 4 different histograms have been created. The `color` argument gives each site histogram it's own color outline to help us distinguish it from the other graphs. [From looking at the graph, it seems like Metacritic and Rotten Tomatoes have uniformly spread review scores, whereas Fandango and IMDB have their scores concentrated around 4.]{color="red"}

[Another option for using aesthetics to map values of `Rating` to different values of `Rating_Site` is to use the argument `fill =` instead of `color =`. Instead of outlines, `fill =` depicts bars filled in with different colors. Let's use this option to visualize differences in `Rating` distributions of the four sites.]{color="blue"}

1.  Create a histogram depicting the distribution of `Ratings` for each site using bars filled with different colors.

```{r}
reviews %>% 
  ggplot(aes(x = Rating, fill = Rating_Site)) +
  geom_histogram(bins = 30)
```

## Density Plots

On the last screen, we learned how to tell `ggplot` to create different plots on the same axis, each one corresponding to a different movie site. We saw Fandango and IMDB have scores concentrated at around 4, while the other two have more spread out scores.

One nice aspect about the `reviews` data that the values in the `Rating` column are relatively contained. The scores range from 1 to 5 and go down to the hundredths place in terms of how fine the score can be.

[In other cases, the values we want to get a histogram for might contain a much larger range or have a much higher resolution (i.e. a smaller decimal place). When this happens, it can be hard to put the data into bars that we can easily visualize.]{color="red"} `ggplot2` provides another visualization that performs the same role as `geom_histogram()`, but uses a smoother shape instead. This function is `geom_density()`, which creates a sort of "smoothed" histogram called a density plot. We provide an example below:

```{r}
reviews %>%
  ggplot(aes(x = Rating)) +
    geom_density()
```

The x-axis still shows `Rating`, but we have a different y-axis called `density`. `density` represents the proportion of the data that a particular `Rating` value has in the data. For example, `Review` scores of 3.5 make up about 55% of the `reviews` data.

`geom_density()` and `geom_histogram()` convey the same visualization in slightly different ways. Depending on what the values are in the variable you want to see the distribution of, you may opt for one over the other. The best way to judge this is to try out both and see which graph better conveys the information you want to tell.

Now you can get some practice looking at the distribution for each movie site using `geom_density()`.

1.  Create a smoothed histogram depicting the distribution of Ratings for each site using bars filled with different colors. Use the color argument to distinguish between the different movie sites

```{r}
reviews %>% 
  ggplot(aes(x = Rating, color = Rating_Site)) +
  geom_density()
```

## Another Way to Visualize Data Distributions

So far, we've covered the use of histograms and density plots to visualize the distributions of the movie review data. They've allowed us to see that the review score distributions between the four sites are indeed different, just by examining the different shapes of the resulting graphs.

There is a specific weakness with these types of visualizations though. We know the distribution for the `Ratings` for each in terms of how many of them fall within a certain bin or value. The histogram and density plot allow us to show that one site has much more 4 star reviews than another. Recall earlier in the lesson that we calculated the average score for each of the sites. Sometimes we would prefer to have data summarized in terms of these single values since it allows more direct comparison. Counts from a histogram can be comparable in cases where two groups have similar representation in data, but this would not be the case with imbalances.

[So, it merits working with a visualization that both: 1) looks at the distribution of the data, but 2) puts things in terms of summary values like an average.]{color="blue"} The next type of visualization we will cover is the box plot. Like bar graphs, box plots visualizes data distributions, whether we are looking at the data as a whole or by group. A box plot looks like the following:

![](https://s3.amazonaws.com/dq-content/275/box_examp.svg)\

We will dissect the important aspects of the graph below:

-   The x-axis of the graph contains group information, and each group is associated with a box-like figure. This means that we will be able to directly compare distributions between groups. In our case, this would be `Rating_Site.`

-   The y-axis contains the variable that we are trying to understand the distribution of. In our case, we would be plotting `Rating` for each movie site.

We will discuss the specifics of the individual boxplots on the next screen, but from looking at the visualization, we can understand a few things about the relationship between the group and the distribution of the variable of interest:

-   The boxes for `Group_1` and `Group_3` are narrower than the box for `Group_2.` **This tells us that the values of `Variable` for `Group_2` are more spread out than they are for the other groups.**
-   The black line in the middle of the boxes represents the value at the center of the data. For `Group_2` and `Group_3`, this value falls in the center of the boxes. This tells us that the values that are larger and smaller than the middle value are about equally spread out.
-   For `Group_1`, the black line is closer to the top of the box. **This tells you that the values that are larger than the middle value are close together, while those smaller than the middle value are more spread out.**

To create a box plot using ggplot2, the syntax for creating the data layer and mapping data to x and y variables is familiar.

```{r}
reviews %>%
  ggplot(aes(x = Rating_Site, y = Rating)) +
  geom_boxplot()
```

You'll add a geom_boxplot() layer to specify creation of a box plot.

## Anatomy of a Box Plot

In general, we can see that the box representing Fandango ratings is higher up on the y-axis than those for the other sites. We can also see the Rotten Tomatoes ratings appear to be more spread out, which is consistent with what we saw when we plotted the data using histograms. While you've been able to glean some information from this box plot, we'll take some time to dig deeper into the individual components to fully understand all they can tell us about data.

Box plots are also known as five-number summaries. The five numbers refer to five percentiles that are shown for each plot:

![](https://s3.amazonaws.com/dq-content/275/annotated_boxplot.svg)\
The five percentiles summarized by a box plot are:

-   **The largest value**: Represented by the top of the black line extending from the top of the box. - - This line extending from the middle box is also known as a "whisker".
-   **The third quartile (Q3)**: Represented by the top of the box. The third quartile represents the number in the data such that 75% of the values in the data are smaller than this number.
-   **The median**: Represented by the thick black line. The median is the value that falls in the middle of the data. Another way to phrase this is that 50% of the values in the data are smaller than the median.
-   **The first quartile (Q1)**: Represented by the bottom of the box. 25% of the values are smaller than the first quartile.
-   **The smallest value**: Represented by the bottom of the black line extending from the bottom of the box.

The white box, bounded by Q3 and Q1, is referred to as the Interquartile Range or IQR. **The IQR encompasses 50 percent of the data, and is calculated by subtracting Q1 from Q3.**

Notice that there are some points that fall below the bottom of the black lines that represent the smallest values. These points are referred to as outliers. Outliers are data points that would be considered "extreme" given what's present in the rest of the data. Outliers can be extremely small or extremely large, and it seems that IMDB and Metacritic have some strangely low scores. [It's important to note that outliers are always defined relative to another set of values. One value may be "extreme" compared to one set of values, but normal in another.]{color="red"}

**`ggplot` uses a formula to determine whether or not a data point is an outlier.** When you make a box plot using `ggplot2`, data points that fall below `Q1 − 1.5 * IQR` or above `Q3 + 1.5 * IQR` are defined as outliers. Everything else that falls within the range of `Q1 − 1.5 * IQR` to `Q3 + 1.5 * IQR` is considered for smallest or largest value. This definition is based on the work of statisticians, and you'll learn more about it in later courses.

Based on these components of a box plot, what can we learn about the movie rating data? Here are some observations:

-   Values of `Rating` for Rotten Tomatoes are spread out, indicating they regularly give movies ratings that range from poor to excellent.
-   The range of values of `Rating` for Fandango and IMDB are both quite narrow. Fandango's lowest reviews are around 2.5, whle outliers indicate that IMDB has some reviews that are between 2 and 2.4.
-   Fandango's median for values of `Rating` is higher than the median of the other sites, indicating Fandango tends to give higher ratings.

Does the box plot you made support the idea that Fandango's reviews are biased? Which site do you think would provide the most unbiased reviews?

1.  In the previous exercise, you created a box plot to visualize summaries of ratings for Fandango, IMDB, Metacritic, and Rotten Tomatoes. Add layers to your plot so it fits the following specifications:

-   White panel background
-   The plot title: "Comparison of Movie Ratings"

```{r}
reviews %>%
  ggplot(aes(x = Rating_Site, y = Rating)) +
  geom_boxplot() +
   labs(
    title = "Comparison of Movie Ratings"
   ) +
  theme(
    panel.background = element_rect(fill = "white")
  )
```

## Representing Categories: Introducing Factors

Before we wrap up the lesson, it's worth learning another aspect of R that can help us tune our visualizations. We've learned most of the fundamental data types in R: characters (strings), doubles and logicals. Each of these types represent common representations of data: text, numbers and yes/no, respectively.

Throughout this lesson, we've worked with the movie rating data and looked at how the distribution of ratings differed for each site. In our visualizations, we've used `Rating_Site` as our independent variable. As a string, R automatically sorts it into alphabetical order. But what if we wanted it to sort `Rating_Site` a different way?

**R gives us a way to do this with a data structure called factors.** Factors are how R represents **categorical data**, data that can be sorted into different categories. We can think of `Rating_Site` as a sort of categorical variable; it contains 4 distinct sites: Fandango, IMDB, Metacritic and Rotten Tomatoes. In R, we refer to each of the individual categories as levels. Thus, each of the movie sites are levels of `Rating_Site.`

We can take any column and convert it into a factor variable using the `factor` function. Currently, `Rating_Site` is made of strings, so we'll make a new column that takes it and converts it into a factor.

```{r}
reviews <- reviews %>%
  mutate(
    Rating_Site_cat = factor(Rating_Site)
  )

reviews %>% pull(Rating_Site_cat)

glimpse(reviews)
```

As a reminder, we can use the `pull()` function to extract a single column as a vector. We recommend using the `pull()` function over`$`or double-bracket notation because it flows better with the`%>%`operator and increases readability.

On the surface, it looks as if nothing has happened to the original `Rating_Site` column. Factors are useful us because of how they are implemented in R. When we view factors from our perspective, they seem like strings. However, from R's perspective, factors are actually numbers. We'll demonstrate this below.

```{r}
reviews %>% pull(Rating_Site_cat) %>% levels()
```

Using the `levels()`function, we can look at the different levels of a factor. These still look like strings, but they actually describe a ranking! [In this ranking, Fandango is considered to be the "first" item, so it's actually coded as `1` by R. Likewise, IMDB is the second item in the ranking, so it's coded as `2`, and so on.]{color="red"}

**Factors have many other uses, but for visualization purposes their value comes from their numerical nature. If we wanted R to rearrange the movie sites on a plot, we could convert it into a factor and actually assign the levels we want. Then, in the plot, R will sort the factor according to these assigned levels.**

For example, if we wanted to go in the reverse order, we could code the following:

```{r}
reviews <- reviews %>%
  mutate(
    Rating_Site_cat = factor(Rating_Site, levels = c("Rotten_Tomatoes", "Metacritic", "IMDB", "Fandango"))
  )
```

Using the `levels` argument within `factor()`, we can specify the ranking that we want the factor variable to take. For our exercise, we'll use what we've learned and confirm that rearranging the factors can rearrange the levels on a plot.

1.  In the `reviews` data, create a new column called `Rating_Site_cat.` This column should take the `Rating_Site` column and convert it into a factor with the following levels (in this order):

-   First level should be "Metacritic"
-   Second level should be "Rotten Tomatoes"
-   Third level should be "Fandango"
-   Fourth level should be "IMDB"

2.  Using this new `Rating_Site_cat` column for the x-axis, create a series of boxplots using the `Rating` column. Can you see that the order of the sites is different from the original boxplot we made?

```{r}
reviews <- reviews %>% 
  mutate(
    Rating_Site_cat = factor(Rating_Site, levels = c("Metacritic", "Rotten_Tomatoes", "Fandango", "IMDB"))
  )

reviews %>% ggplot(aes(x = Rating_Site_cat, y = Rating
                       )) +
  geom_boxplot()
```

## Summary

In this lesson, as we investigated possible movie rating bias, you've learned to represent the same data in four different ways:

Bar Charts:\
![](https://s3.amazonaws.com/dq-content/275/ratings_bar_chart.svg)\
Density Plot:\
![](https://dq-content.s3.amazonaws.com/275/fandango-density.png)\
Histograms:\
![](https://s3.amazonaws.com/dq-content/275/color_fill_histogram.svg)\
Box Plots:\
![](https://s3.amazonaws.com/dq-content/275/reviews_box_plot.svg)\

As we discussed earlier in this course, building intuition around when to use different types of visualizations to understand your data is an important skill you will develop. Here are some general guidelines:

-   Bar charts and density plots may be used for showing a quick summary of your data, such as averages or counts of the number of instances of a value that occur for a given variable. Often, these will be one of the first visualizations you use because you are trying to understand what's present in your data before progressing to more involved analyses.
-   Histograms are useful for visualizing distributions of data when you want to know the shape of a distribution (in other words, where most values are clustered). By knowing the shape of your data's distribution, you will know what to expect to see in terms of an average or median. The shape will also clue you into if there are outliers present.
-   Box plots provide an informative summary of the shape, spread, and center of your data. It's important to remember that all visualizations are tools for us to communicate a message. Our visualization needs may change based on what questions we want to answer. As you learn more visualizations, remember that certain visualizations are better at answering some questions than others.

# **3. Visualising Relationships between variables**

## Introduction

In the previous lessons, we've learned how to use `ggplot2` package to create visualizations of data distributions. Histograms, density plots and box plots are all viable options for us to choose from. After using these plots to understand how our data is distributed, we can move forward with trying to understand how the variables in our dataset are related to each other.

We are often interested in relationships between variables because we can often take advantage or learn from these relationships. In this lesson, we'll learn another set of `ggplot2` functions that will help us visualize these relationships. We saw from the life expectancy data of the National Center for Health Statistics that life expectancy has increased as time has progressed. We'll continue to look at this data in this lesson and learn more plot types:

![](https://s3.amazonaws.com/dq-content/273/ggplot_6.svg)\

1.  Import the "life_expec.csv" file into R. Save it as a tibble named life_expec.

## Processing the Data for Visualisation

In it's current form, the `life_expec` data contains life expectancy data for multiple subgroups in the United States. For the purposes of this lesson, we'll need to filter down the data to make it easier to plot later. We'll focus on the life expectancy of men and women in the United States, regardless of race.

In the previous lesson, when you investigated life expectancies averaged across Americans of different sexes and races, you used the `filter()` function to create a new dataframe containing only rows for which:

-   Values of the `Race` variable were `"All Races"`
-   Values of the `Sex` variable were `"Both Sexes"`

You will need to select a subset of the `life_expec` data that contains observations for the populations of U.S. men and women. You'll need to filter `life_expec` to retain rows for which values of the `Sex` variable are either `Female` or `Male` and, since we are not yet investigating life expectancies for different races, values of `Race` are `All Races`.

![](https://s3.amazonaws.com/dq-content/274/select_men_women.svg)\

Let's create a new tibble containing only the data you'll use to visualize changes in U.S. men's and women's life expectancies over time.

1.  Create a new dataframe, `life_expec_sex`, containing only rows for which the `Sex` variable has the value "Female" or "Male" and the `Race` variable has the value "All Races."

```{r}
life_expec_sex <- life_expec %>%
  filter(
    Sex != "Both Sexes",
    Race == "All Races"
    )
# OR use the following
# life_expec_sex <- life_expec %>%
#   filter(Race == "All Races" & Sex != "Both Sexes")
```

## Creating Line Graphs By Groups

Now that we've processed the data to just have the two sexes, we can add some depth to our line graph. We learned how to create one in the first lesson, so we'll extend our knowledge here.

In order to directly compare the life expectancies between men and women, we should have them be on the same axis. We could use the color or fill argument in the aes() function as we did in the Visualizing Data Distributions lesson, but we'll learn another useful argument to allow us to distinguish between two groups of lines. If we used the color argument on the data, the plot would look like:

![](https://s3.amazonaws.com/dq-content/274/color_sex_graph.svg)\

We can plot men's and women's life expectancies on the same set of axes, and then style the lines differently to allow us to tell between them:

![](https://s3.amazonaws.com/dq-content/274/mult_lines.svg)\

Another argument we can use to group data into separate lines is the lty argument. [The argument lty stands for "line type".]{color="red"} Just as with color and fill, lty takes in a variable that signifies the different groups in the data:

```{r}
# data %>%
#   ggplot(aes(x = variable_1, y = variable_2, lty = group_var)) +
#   geom_line()
```

The great thing about ggplot2 is that we can use multiple arguments at the same time to help us distinguish the groups. If we also wanted to color the lines according to group, we could also include color in aes() as well.

```{r}
# data %>%
#   ggplot(aes(x = variable_1, y = variable_2, lty = group_var, color = group_var)) +
#   geom_line()
```

Let's create a line graph to visualize changes in men's and women's life expectancies on the same axis.

1.  Create a line graph with the change in men's and women's life expectancies over time represented by lines of different colors.

```{r}
life_expec_sex %>% ggplot(aes(x = Year, y = Avg_Life_Expec, lty = Sex, color = Sex)) + 
  geom_line()
```

## Zooming In On Our Axes

In the new graph we've created, we can see the subtle differences in changes in men's and women's life expectancies over time:

![](https://s3.amazonaws.com/dq-content/274/color_sex_graph.svg)\

The graph suggests that, although life expectancies for U.S. men and women followed similar patterns over the past 100 years, women have tended to live longer by about 5 years on average. This trend was not always the case. Looking before 1950, life expectancies appear to have fluctuated from year to year. Afterwards, the increase in life expectancy is relatively smooth.

There are often times where we will want to hone in on a subset of our data that catches our attention. In this case, we want to have a closer look at life expectancies prior to 1950. We won't need to look at the rest of the graph since we want to zoom in on this time period. One way we could do this is to `filter()` out these particular years. Another way which can prove useful is to set scale limits, or change range of your axes so you can display only a portion of your data.

For example, let's say that we wanted to zoom in on this precipitous drop in life expectancy that occurs before 1925. In the graph's current form, it's hard to really grasp when it happens.

In order to change the scale limits of our axes, we need to use the `xlim()` and `ylim()`. These functions take in 2 numbers: the first number represents the lower limit of the axis, and the second number represents the upper limit.

```{r}
life_expec_sex %>% 
  ggplot(aes(x = Year, y = Avg_Life_Expec, color = Sex)) +
  geom_line() +
  xlim(1915, 1920) +
  ylim(35, 60)
```

**In graph above, the x-axis years now range from 1915 to 1920, and the y-axis life expectancies range from 35 to 60 years old. The drop happens around 1918, which corresponds to the deadly Spanish Flu.** By default, when you use `ggplot()` to create a graph, all observations will be included. Looking at the graph of life expectancies for the years 1915 to 1920 allows you to clearly visualize the devastating effect that the flu pandemic had on life expectancies.

Earlier, we discussed the interesting differences in life expectancy fluctuations before and after 1950. Let's create a graph focused on life expectancy data from before 1950.

1.  Create a graph using the `life_expec_sex` data of men's and women's life expectancies between 1900 and 1950.

```{r}
life_expec_sex %>% 
  ggplot(aes(x = Year, y = Avg_Life_Expec, color = Sex)) +
  geom_line() +
  xlim(1900, 1950)
```

## Plotting Subgroups Within Groups

As of now, we have a visualization that looks at changes in men's and women's life expectancies from 1900 to 1950.

The graph looks at men and women as a whole, but perhaps this level of generality is masking some deeper relationships with life expectancy over time. On this screen, we'll learn how to further breakdown a graph into further subgroups. We could also hypothesize that race plays a role in life expectancy. It is well documented in research that African-Americans have lower life expectancy compared to the rest of the population. Will this trend be represented in the data?

To explore this question, we'll need to `filter()` for a different subset of data from the `life_expec` dataframe:

-   Values of `Sex` that are either "Male" or "Female"
-   Values of `Race` that are either "Black" or "White"

Once we have this filtered data, we'll need to specify in `ggplot()` how to distinguish between the subgroups. Overall, we have 4 groups: white males, white females, black males and black females. A single argument (i.e. `color`, `fill`, `lty`) helps us distinguish one grouping column (i.e. Race or Sex).

In order to distinguish between all four groups, we need to specify both `Sex` and `Race` as grouping columns in `ggplot()` for separate grouping arguments. For example, we may do:

```{r}
# data %>% 
#   ggplot(aes(x = variable_1, y = variable_2, color = group_var_1, lty = group_var_2)) +
#   geom_line()
```

Let's filter the `life_expec` dataframe to retain only values of the `Sex` and `Race` variables that you'll include in your visualization of U.S. life expectancy by race and sex. We'll have four distinct subgroups in the data, so we'll create the visualization with each of them.

As a note, it's generally good practice to limit how many subgroup lines are on the same plot. Four is fine for now, but we can imagine that having 8 or 16 groups (lines) would make the graph difficult to read and interpret.

1.  Create a new dataframe, `life_expec_sex_race`, that contains values of `Sex` that are either "Male" or "Female" and values of `Race` that are either "Black" or "White."

2.  Using `life_expect_sex_race`, create a line graph that distinguishes between white males, white females, black males and black females.

-   Use the `lty` argument for `Race`
-   Use the `color` argument for `Sex`

```{r}
life_expec_sex_race <- life_expec %>% 
  filter(Sex != "Both Sexes",
           Race != "All Races")

life_expec_sex_race %>% 
  ggplot(aes(x = Year, y = Avg_Life_Expec, lty = Race, color = Sex)) +
  geom_line()
```

## Manipulating Graph Aesthetics

In the last screen, we developed a line graph that successfully allows us to distinguish between the four different subgroups within `Race` and `Sex.`

By default, the `ggplot2` package uses these default colors and line types when working in the `aes()` layer. If you were feeling artsy or dissatisfied with the defaults, `ggplot2` allows you to customize these arguments extensively. There are separate functions to change graph colors and line types. To change the colors, we need to use the `scale_color_manual()` function. For line type, we need to use the `scale_linetype_manual()`function.

As you've now seen is often the case with creating graphs with `ggplot2`, modifying line colors and types involves adding another layer to your graph. As an example, let's change the colors representing men's and women's life expectancies to "magenta" and "orange":

```{r}
ggplot(data = life_expec_sex_race, 
  aes(x = Year, y = Avg_Life_Expec, color = Sex, lty = Race)) +
  geom_line() +
  scale_color_manual(values = c("magenta", "orange"))
```

[How does `ggplot` decide what color gets assigned to each group? It looks at the order (numeric or alphabetic) of the grouping column.]{color="red"} In this case, "Female" comes before "Male" alphabetically, so it is associated with the first value in `scale_color_manual()`: magenta.

For `scale_linetype_manual()`, we have a similar syntax to follow:

```{r}
ggplot(data = life_expec_sex_race, 
  aes(x = Year, y = Avg_Life_Expec, color = Sex, lty = Race)) +
  geom_line() +
  scale_color_manual(values = c("magenta", "orange")) +
  scale_linetype_manual(values = c("longdash", "dotdash"))
```

Changing the aesthetics of the graph boils down to adding more layers to our plot! This is a great demonstration of the power that the "layer" based approach that `ggplot2` implements.

For a more complete guide to the available colors and line types you can use in `scale_color_manual()` and `scale_linetype_manual()`, you can refer to these links:

-   This [guide](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf) contains R colors labeled with names you can use to reference them.
-   Here is a [guide](http://www.cookbook-r.com/Graphs/Shapes_and_line_types/) to line types in R.

As you gain practice creating line graphs and other types of data visualizations, you will become skilled at using aesthetics that represent your data clearly. `scale_color_manual()` and `scale_linetype_manual()` are just for color and line type, respectively, and there are other functions available that let us change other aspects of a graph's aesthetic.

For now, let's practice using different line type and color combinations to visualize life expectancy data.

1.  Using the `life_expec_sex_race` dataframe, create a line graph to investigate differences in how life expectancies of the following populations of Americans changed between 1900 and 2014:

-   White women
-   White men
-   Black women
-   Black men

2.  Differentiate between the two sexes using the following colors: "darkgreen" and "darkorchid"
3.  Differentiate between the two races using the following line types: "values = c(1,4))"

```{r}
life_expec_sex_race %>% 
  ggplot(aes(x = Year, y = Avg_Life_Expec, color = Sex, lty = Race)) +
  geom_line() +
  scale_color_manual(values = c("darkgreen", "darkorchid")) +
  scale_linetype_manual(values = c(1,4))
```

## Another Way To Visualize Variable Relationships

Line graphs are a great way to visualize the relationship between two variables, but just as with visualizing data distributions, there's more than one way to do this. Line graphs are great when we know there is a connection between two successive points on the x-axis. In our example, the x-axis is time in years, so we can think of the final plot as the change in life expectancy through time.

There may be other times where we might not want to have these lines connecting two consecutive points. Sometimes there may not be a clear relationship between two successive points, like when the x-axis contains groups rather than a continuous variable. Another reason for not wanting to use a line graph might be preference. **By definition, a line plot already assumes a linear relationship between two points.** Not all relationships are linear in nature, we might want to not visualize the lines at all so that we are not biased.

**An alternative to the line graph is the scatter plots. Instead of visualizing a connection between two successive points on a plot, a scatter plot merely plots all of the coordinates as points on the plot.**

Let's look at some examples of scatter plots and see how their shape might suggest different types of relationships between variables.

The two variables, `Variable_1` and `Variable_2`, that are depicted in this scatter plot appear to have a positive relationship:

![](https://s3.amazonaws.com/dq-content/276/strong_positive.svg)\
You can tell the relationship is positive because as values of `Variable_1` increase, so do values of `Variable_2.` The points take on a diagonal shape that is higher on the right side. Conversely, scatter plots can also indicate negative relationships between variables:

![](https://s3.amazonaws.com/dq-content/276/strong_negative.svg)\
The points also create a diagonal shape here, but the left side is higher than the right.

Scatter plots can also demonstrate a lack of relationship between variables. In this last scatter plot representing values of `Variable_1` and `Variable_2`, the points are arranged in sort of horizontal band. This shape indicates that `Variable_2` can take on similar values whether or not `Variable_1` is small or large. ![](https://s3.amazonaws.com/dq-content/276/no_relationship.svg)\
Whether a relationship is strong or weak is subjective --- it depends on the person making the interpretation. You'll learn to more precisely define relationships between variables in our upcoming statistics courses. For now, we'll focus on understanding general patterns using scatter plots.

Creating a scatter plot using `ggplot2` is similar to creating a line graph. Instead of using `geom_line()` function, we need to use the `geom_point()` function instead.

-   Specify the two variables for which you want to investigate a relationship in the `aes()` layer.
-   Add a `geom_point()` layer to specify use of points to represent each pair of variable values.

```{r}
# data %>% 
#   ggplot(aes(x = Variable_1, y = Variable_2)) +
#   geom_point()
```

Use the life_expec data to recreate the life expectancy data through time with a scatter plot.

1.  Filter down the `life_expec` to reflect data for all races and both sexes. Assign this data to the variable `life_expec_overall.`

-   `Race` should only have the value "All Races"
-   `Sex` should only have "Both Sexes"

2.  Create a scatter plot that looks at `Year` and `Avg_Life_Expec` with the `life_expec_overall` data.

```{r}
life_expec_overall <- life_expec %>% 
  filter(
    Race == "All Races",
    Sex == "Both Sexes"
  )
life_expec_overall %>% ggplot(aes(x = Year, y = Avg_Life_Expec)) +
  geom_point()
```

# **4. Improving Visualisations**

## Introduction

Throughout this lesson, we've learned how to use the `ggplot2` package to create interesting and visually appealing graphs. Visualizations are important because they appeal more to our sense of sight and make patterns in the data easier to parse out. We can look at how the data is distributed through histograms and boxplots, and we can also look at relationships using line graphs and scatter plots.

With what we know now, we can already produce informative graphs, but there's still some important topics to cover before we wrap up this course. We'll dedicate this lesson to covering these topics to make sure that you know how to make some truly compelling graphs with your data.

We'll be working again with the life expectancy data of the National Center for Health Statistics:

![](https://s3.amazonaws.com/dq-content/273/ggplot_6.svg)\
The data also contains some information on the age adjusted death rate in the United States as well. It would be interesting to see how the death rate has changed alongside the life expectancy rate. We'll explain what death rate is as we progress through the lesson. At the end of the lesson, we will have created some visualizations of this data to look at this relationship.

1.  This is slightly different from what we've previously done, but we're going to change the column names to lower case. Lower case column names are easier to type, especially with longer names. Recall we can change the column names to lower case using the `str_to_lower()` function from the `stringr` package.

-   `Year` should be changed to `year`
-   `Race` should be changed to `race`
-   `Sex` should be changed to `sex`
-   `Avg_Life_Expec` should be changed to `avg_life_expec`
-   `Age_Adj_Death_Rate` should be changed to `age_adj_death_rate`

```{r}
life_expec <- read_csv("life_expec.csv")
colnames(life_expec) <- str_to_lower(colnames(life_expec))
```

## Understanding The Death Rate

Before we do any plotting, it's worth taking some time to consider the part of the life expectancy data that we haven't yet used before: the age adjusted death rate.

[The death rate can be thought of as the "opposite" of life expectancy. Whereas life expectancy tells us how long an average person will live, the death rate tells us how many people will die on average as a fraction of a given number of people.]{color="blue"}

*Death rate is typically expressed as "number of people who will die per 100,000 people". For example, the (age adjusted) death rate for all races and sexes in 2014 was 724.6. This means that out of 100,000 people about 724 people will have died in 2014 on average. It's important to keep the denominator constant (i.e 100,000) if we are comparing rates between two years: it will make sure the rates are comparable.*

We must also address a problem in the data that might hamper our visualization down the line: scale. [The life expectancy column ranges from about 30 to 80, but the death rate ranges from about 600 to 3800.]{color="red"} If we plot both of these lines on the same plot, the life expectancy will look distorted and flat:

We know that life expectancy increases with time, but it's hard to tell because the scale makes this increase look flat. It would be better to get the death rate to be on a similar scale to life expectancy, so that the trends are still discernible from the plot.

1.  Create a new column in the `life_expec` data called `scaled_age_adj_death_rate.` It should take the old `age_adj_death_rate` column and divide it by 10. This will put death rate on a similar scale to life expectancy.

```{r}
life_expec <- life_expec %>% 
  mutate(
    scaled_age_adj_death_rate = age_adj_death_rate/10
  )

```

## Plotting Two Different Dependent Variables

Now that we've loaded in the life_expec data and scaled down the death rate, we can get to visualizing both the life expectancies and average death rate over time in the United States. With our current knowledge, we don't know how to do this; so far, we've only been plotting one dependent variable against one independent variable. In this case, we'll need to produce a plot with two dependent variables, as shown below: ![](https://dq-content.s3.amazonaws.com/276/double-line.png)\
In order to plot multiple dependent variables on a plot at the same time, we need to rethink how we lay out our `ggplot` layers. When we've written a line graph, we wrote it like this:

```{r}
# data %>%
#   ggplot(aes(x = variable_1, y = variable_2)) +
#   geom_line()
```

We haven't really discussed this detail, but have you noticed that we don't have to pass anything into the `geom_line()` function? We've learned before that functions take in inputs and give an output, but how does `geom_line()` know to plot `variable_1` against `variable_2`?

The answer is inheritance! In the `ggplot()` layer above it, we define the axes of the graph using the `aes()` function. With how `ggplot2` works, any layers that follow it will inherit this aesthetic, so we don't need to write it again! With this in mind, we can rewrite the same graph like the following:

```{r}
# data %>%
#   ggplot(aes(x = variable_1)) +
#   geom_line(aes(y = variable_2))
```

In this case, we don't define the `y` argument in the `ggplot()` layer, but instead in `geom_line()`. Written this way, the `geom_line()` layer knows to use `variable_1` for the x-axis, and it is told to use `variable_2` on the y-axis.

This way of coding the plot gives us a way to plot two different dependent variables. If we associated a single `geom_line()`to a single dependent variable, we can just use two separate functions within the same plot!

```{r}
# data %>%
#   ggplot(aes(x = variable_1)) +
#   geom_line(aes(y = variable_2)) +
#   geom_line(aes(y = variable_3))
```

This way of coding the plot is extremely useful if we want to compare different trends across time (or other independent variable). Let's apply what we've learned to the life expectancy data.

1.  Filter the `life_expec` data so that:

-   `race` only contains the value "All Races"
-   `sex` only contains the value "Both Sexes"
-   assign this new tibble to `life_expec_race_sex`

2.  Using `life_expec_race_sex` data, create a line graph that plots both `avg_life_expec` and `scaled_age_adj_death_rate` against year.

```{r}
life_expec_race_sex <- life_expec %>% 
  filter(
    race == "All Races",
    sex == "Both Sexes"
  )

life_expec_race_sex %>% ggplot(aes(x = year)) +
  geom_line(aes(y = avg_life_expec)) + 
  geom_line(aes(y = scaled_age_adj_death_rate))
```

## Restructuring Our Data

Just from working with the data previously, we know that the rising line is the life expectancy and the falling line is the death rate. Recall though that any visualization that you create should be able to be understood without knowing the data. If we gave this to someone who hasn't worked with the data, they wouldn't know what each line represents. Furthermore, take note of the vague y-axis title: it's still `avg_life_expec`!

We taught this way of graphing two separate column because it's a nice way of quickly seeing what the data looks like. It's not ideal for creating polished graphs though. We will learn a way to graph multiple columns in a polished way, but before this, we must teach a crucial concept about data formats.

Instead of thinking about `avg_life_expec` and `scaled_age_adj_death` rate as two separate columns, what if we thought of them as two groups of rows within data? That is to say, some of the rows are dedicated to life expectancy, while the other rows are dedicated to death rate. To visualize this, we'll look at a brief snippet of the data in its current form:

| year | race      | sex        | avg_life_expec | scaled_age_adj_death_rate |
|------|-----------|------------|----------------|---------------------------|
| int  | chr       | chr        | dbl            | dbl                       |
| 2014 | All Races | Both Sexes | 78.9           | 72.46                     |
| 2013 | All Races | Both Sexes | 78.8           | 73.19                     |
| 2012 | All Races | Both Sexes | 78.8           | 73.28                     |
| 2011 | All Races | Both Sexes | 78.7           | 74.13                     |
| 2010 | All Races | Both Sexes | 78.7           | 74.70                     |

Recall that we can tell `ggplot()` to automatically create different lines on the same graph if we specify a grouping column in an argument like `color` or `lty.` With this in mind, it would be better if our data were restructured to have a grouping variable, so that we can take advantage of this. Ideally, we would want to restructure the data so that it looks like this:

| year | race      | sex        | column                    | value |
|------|-----------|------------|---------------------------|-------|
| int  | chr       | chr        | chr                       | dbl   |
| 2014 | All Races | Both Sexes | avg_life_expec            | 78.9  |
| 2014 | All Races | Both Sexes | scaled_age_adj_death_rate | 72.46 |
| 2013 | All Races | Both Sexes | avg_life_expec            | 78.9  |
| 2013 | All Races | Both Sexes | scaled_age_adj_death_rate | 73.19 |
| 2012 | All Races | Both Sexes | avg_life_expec            | 78.8  |
| 2012 | All Races | Both Sexes | scaled_age_adj_death_rate | 73.28 |
| 2011 | All Races | Both Sexes | avg_life_expec            | 78.7  |
| 2011 | All Races | Both Sexes | scaled_age_adj_death_rate | 74.13 |
| 2010 | All Races | Both Sexes | avg_life_expec            | 78.7  |
| 2010 | All Races | Both Sexes | scaled_age_adj_death_rate | 74.7  |

Notice that instead of having `avg_life_expec` and `scaled_age_adj_death_rate` as distinct columns, the information is slightly rearranged as we've described. Information in column contains information on whether a number in the value column comes from either the old `avg_life_expec` and `scaled_age_adj_death_rate` columns. [The data still fundamentally contains the same information but in a different format, which we call long format.]{color="red"} It's "long" because the data has essentially doubled in length since we must list out what row comes from which column. [Before this transformation, we would say that the data was in wide format.]{color="blue"}

The distinction between long and wide format has important significance to us. Typically, humans prefer to read data in wide format because we can see all of the information associated with a year in the `life_expec` data. **However... long format data is better for `ggplot2`!** The reason for this is because now we have a useful grouping `column` that will help us create different lines via column. Now that you know about wide and long format, we can learn the function to do this transformation.

## A Better Approach To Plotting Multiple Columns

On the last screen, we learned about wide and long formats of data. Wide format generally has more columns:

![](https://dq-content.s3.amazonaws.com/276/wide.png)\
Whereas long format has more rows: ![](https://dq-content.s3.amazonaws.com/276/long.png)\

Transforming data from wide to long format is so common that this action has been given its own name: pivoting. Since it's so common, there's also a function that performs the pivoting for us: the `pivot_longer()` function, which comes from the `tidyr` package. We'll cover this topic in more detail in a later course. For now, we'll use `pivot_longer()` for the purposes of improving our visualization of life expectancy and death rate.

Our life expectancy data is currently in wide format, so we need to use `pivot_longer()` to restructure it. There are three arguments that you should provide to the `pivot_longer()` function, which we'll go through in an example below. In order to pivot the `life_expec` data into long format described above, we would write:

```{r}
life_expec_long <- life_expec %>%
  pivot_longer(
    cols = c(avg_life_expec, scaled_age_adj_death_rate),
    names_to = "column",
    values_to = "value"
    )
```

The first argument is `cols`, where we need to specify the columns whose values we want to "stack" on top of each other. In this case, this is `avg_life_expec` and `scaled_age_adj_death_rate.` The `names_to` argument represents a new grouping column that will help us distinguish between the rows once they're stacked. In our case, we are calling it `column.` The final argument `values_to` decides what the column name that contains all the values should be.

Take some time to become familiar with the example code above and then apply it to our `life_expec_race_sex` data.

1.  Take the `life_expec_race_sex` data and use `pivot_longer()` to transform it into long format. Use the following values for the arguments:

-   `cols` should be a vector containing `avg_life_expec` and `scaled_age_adj_death_rate`
-   `names_to` should be called "column"
-   `values_to` should be called "value"
-   Assign this new tibble to the variable `life_expec_race_sex_long`

```{r}
life_expec_race_sex_long <- life_expec_race_sex %>% 
  pivot_longer(
    cols = c(avg_life_expec, scaled_age_adj_death_rate),
    names_to = "column",
    values_to = "value"
  )
```

## Plotting Long Format Data

By converting the data into a long format, we now have access to a valuable grouping column that let's us create two lines based on the columns we want to plot. Instead of having to use two `geom_line()`functions, we can specify this grouping column with an argument like `color`, and `ggplot()` will automatically plot the two lines, as desired.

We can apply what we learned the **Visualizing Data Distribution** lesson. We spent a fair amount of time learning about data format and its significance to plotting, and all of our effort will culminate here.

Using the plot above as a reference, add `life_expec_race_sex_long` to improve this visualization. The plot should look the same, but the improved version should have a legend to help us distinguish between life expectancy and death rate lines.

1.  Create a plot with two lines: one looking at `avg_life_expec` over time and another looking at `scaled_age_adj_death_rate` over time.

-   Use the `color` argument to distinguish between the two columns.

```{r}
life_expec_race_sex_long %>% 
  ggplot(aes(x = year, y = value, color = column)) +
  geom_line()
```

## Polishing The Legend

The above is much better than what we produced when we used two `geom_line()` layers. We have a legend and colors that help us distinguish between the two lines. In order to fully flesh out this graph, we need to work on the axes labels and the legend itself. Remember we must always be thinking about a viewer who will not see the data!

In the Visualizing Relationships Between Variables lesson, we used the `scale_color_manual()` function to help us change the colors of the lines in a line graph. We can also use this function to alter how the legend is formatted so that it is easier to understand from a reader's perspective.

The `values` argument is used to alter line color in the `scale_color_manual()` function. We'll learn 3 other arguments that we can supply to the function to help alter the legend. They are as follows:

-   `name`: we can supply a string here to change we want the title of the legend to be
-   `breaks`: we can use this to change the order that the groups appear in a legend. This will be a string vector of the groups that are present in the data
-   `labels`: we can use this to change the name of each group that appears in the legend. Like with `breaks`, this is also a string vector of the groups that are present in the data

Together with `values`, these 3 arguments form a good basis for making quality legends in your graphs. We offer a pseudocode example to show how you might use all of these arguments in an graph:

```{r}
# Assuming that group_var has one of two values: "A" or "B"

# data %>% 
#   ggplot(aes(x = variable_1, y = variable_2, color = group_var)) +
#   geom_line() +
#   scale_color_manual(
#     name = "Grouping Variable", # title of legend
#     values = c("red", "blue"), # colors of lines on plot and legend
#     breaks = c("B", "A"), # Showing B group before A
#     labels = c("Group B", "Group A") # labels for each group on legend
#   )
```

Note carefully that `color` was used in the `aes()` function to help distinguish between groups. Because of this, we use `scale_color_manual()` to change the appearance of the graph. If we had used `fill`, we would have to use a similar, but different function called `scale_fill_manual()`. The arguments are the same, but they are designed to be used with their respective arguments.

With this knowledge on hand, finalize the graph showing the trends in life expectancy and death rate!

1.  Use `scale_color_manual()` to adjust the legend as follows:

-   the title of the legend should be "Trend"
-   the color for the life expectancy line should be "forestgreen", while death rate should be "orangered"
-   the label for life expectancy should be "Avg. Life Expectancy", while death rate should be "Death Rate (Age Adjusted)"

```{r}
life_expec_race_sex_long %>% 
  ggplot(aes(x = year, y = value, color = column)) +
  geom_line() +
  scale_color_manual(
    name = "Trend",
    values = c("forestgreen", "orangered"),
    labels = c("Avg. Life Expectancy", "Death Rate (Age Adjusted)")
  )
```

## Creating Multiple Graphs Simultaneously

For the rest of the lesson, we'll discuss another way to create visualizations of data that contains different groups. In the Visualizing Relationships Between Variables lesson, we looked at how to plot the life expectancy of different races and sexes through time. Since each of these trends are directly comparable, we chose to plot everything on the same axis.

Having them on the same graph makes it easier to compare, but perhaps we are not at that stage in the analysis yet. For example, if we were still exploring the data, we might want to isolate each group on its own plot, but still make it easy to have all of the information in front of us. In this case, we will want to give each group their own plot, but have each subplot organized into a neat format.

For this, `ggplot2` provides the `facet_wrap()` function. A "facet" can be thought of as another word for subgroup. Males and females are two facets of `sex` in the life expectancy data. We can provide a grouping variable to `facet_wrap()` to tell it that we want to produce multiple graphs that portray the same information, but use different groups for each plot!

Here's some code that shows how you might use facet_wrap():

```{r}
life_expec %>% 
  filter(race != "All Races",  sex == "Female") %>% 
  ggplot(aes(x = year, y = avg_life_expec)) +
  geom_line() +
  facet_wrap(vars(race))
```

Just as with any of the functions in `ggplot2`, we use `facet_wrap()` as another layer in the code. This time we have removed `race` from `aes()` and moved it into the `facet_wrap()` function. This tells `ggplot2` that we want to create separate plots for the two groups, as shown above.

One slightly unusual aspect of the code above is that we have to pass `race` into the `vars()` function. [The reason for this is out of the scope for our lesson, but in short it essentially lets us to pass in `race` without quotes.]{color="red"} *It is used to select variable.* If we didn't want to use `vars()`, we would actually have to pass in a string "race" into `facet_wrap()` instead (i.e. `facet_wrap("race")`) to produce the same graph.

1.  Create a new tibble called `life_expec_black` that filters `life_expec` as follows:

-   `sex` should exclude "Both Sexes"
-   `race` should be "Black"

2.  Using `life_expec_black`:

-   create a line graph that looks at the relationship between time and life expectancy, and = split the plot into two separate subplots dedicated to each of the groups in `sex.`

```{r}
life_expec_black <- life_expec %>% 
  filter(
    sex != "Both Sexes",
    race == "Black"
  )
life_expec_black %>% ggplot(aes(x = year, y = avg_life_expec)) +
  geom_line() +
  facet_wrap(vars(sex))

```

## Faceting Using Multiple Groups Simultaneously

We use the `facet_wrap()` function to create multiple versions of a plot based on a specified group. In the last screen, we used `facet_wrap()` with the sex column, which gave us two plots. On this screen, we'll learn a close cousin to the `facet_wrap()` function.

`facet_wrap()` is useful in cases where we want to create multiple plots based on one grouping variable. We can use multiple grouping variables inside `facet_wrap()`, but there's a better alternative in this case.

Enter the `facet_grid()` function. `facet_grid()` performs essentially the same function as `facet_wrap()`, but it is designed to format the plots that it creates into a grid. This grid aspect makes it better for use with multiple grouping variables. We show an example use below:

```{r}
# data %>% 
#   ggplot(aes(x = variable_1, y = variable_2)) +
#   geom_line() +
#   facet_grid(
#     rows = vars(group_var_1), 
#     cols = vars(group_var_2)
#   )
```

Since `facet_grid()` is creating a grid, we need to define which variables will form the row and column basis for the grid. Above, we have two grouping variables `group_var_1` and `group_var_2.` The groups in `group_var_1` form the rows, while the groups in `group_var_2` form the columns.

Just as we've done before, we're going to visualize the life expectancy data by both `race` and `sex`, only this time we're going to have them all on separate plots.

1.  Create a new tibble called `life_expec_race_sex` that filters life_expec as follows:

-   `sex` should exclude "Both Sexes"
-   `race` should exclude "All Races"

2.  Create a grid of plots that looks at life expectancy for each of the combinations of `sex` and `race.`

-   use `sex` as the columns
-   use `race` as the rows

```{r}
life_expec_mix <- life_expec %>% 
  filter(
    sex != "Both Sexes",
    race != "All Races"
  )
life_expec_mix %>% ggplot(aes(x = year, y = avg_life_expec)) +
  geom_line() +
  facet_grid(
    rows = vars(race),
    cols = vars(sex)
  )
```
