---
title: "4. Specialised Data Processing"
author: "Ricardo"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float: yes
    pandoc_args: ["--lua-filter=color-text.lua"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load the packages
library(tidyverse)
library(tibble)
library(readr)
library(ggplot2)
library(dplyr)
```

```{cat, engine.opts = list(file = "color-text.lua")}
Span = function(el)
  color = el.attributes['color']
  -- if no color attribute, return unchange
  if color == nil then return el end
  
  -- transform to <span style="color: red;"></span>
  if FORMAT:match 'html' then
    -- remove color attributes
    el.attributes['color'] = nil
    -- use style attribute instead
    el.attributes['style'] = 'color: ' .. color .. ';'
    -- return full span element
    return el
  elseif FORMAT:match 'latex' then
    -- remove color attributes
    el.attributes['color'] = nil
    -- encapsulate in latex code
    table.insert(
      el.content, 1,
      pandoc.RawInline('latex', '\\textcolor{'..color..'}{')
    )
    table.insert(
      el.content,
      pandoc.RawInline('latex', '}')
    )
    -- returns only span content
    return el.content
  else
    -- for other format return unchanged
    return el
  end
end
```

# **1. String Manipulation**

## Introduction

After learning these fundamental concepts, it's important that we know how to manipulate different types of data as we apply what we know.

If we recall from our introduction to R, there are basic data types in R: numbers (integers and doubles), logicals (`TRUE` and `FALSE`), factors, and strings. So far, we mainly worked with numerical data and logicals, but we have yet to really explore strings.

![](https://dq-content.s3.amazonaws.com/496/wordcloud.png)
In this lesson, we'll fill this blank and go through a detailed review of what strings are and what we can do with them.[ Strings are how R represents text, whether we are talking about tweets, electronic medical records or Amazon reviews]{color='red'}. Compared to numerical data, text data can be harder to clean and manipulate since there are lots of words. We also can't typically do numerical calculation directly with text; we need to perform some cleaning steps beforehand.

[Typical work with strings usually has to do with finding specific words or phrases in a larger paragraph, or counting the number of times it appears in a passage.]{color='blue'} By the end of this lesson, we'll know how to use many of the functions that help us with string manipulation, which opens up our capabilities as a programmer.


## Indexing Strings

Before we learn about the various string manipulation functions, we will review an important aspect of strings. A string is also known as a character vector in R. Throughout this lesson, we'll use these two phrases interchangeably. The word "vector" here is important because it hints at how strings are structured in R. Vectors are ordered lists. That means there's a reason behind the "first item" of a vector, the "last item" and so on.

In R, we can locate or index, particular elements of a vector using numbers. The first item in a vector is indexed by the number `1`. For example, we can get the first item of a vector of numbers like below:


```{r}
nums <- 1:5

nums[1]
```


We can think of any string as a vector of letters, numbers and symbols. We denote strings by surrounding them with single quotes as in `'string' `or with double quotes, as in `"string"`. Just like how we can index a numerical vector with numbers, we can also index character vectors in the same way. However, we cannot use a single bracket `[]` notation with character. Doing so would produce unexpected results:


```{r}
words <- "Dataquest is awesome"

words[3]
```

When we see the sentence "Dataquest is awesome", we might be inclined to think R would interpret it as three words. R actually interprets this sentence as a one-element vector containing just that one string.

```{r}
words <- "Dataquest is awesome"

words[1]
```

In order to get a substring of the string, we need to use the `str_sub()` function from the stringr library. The `stringr` library is a component of the `tidyverse` libraries, dedicated to handling strings. To get the first word from the string* "Dataquest is awesome"*, we need to supply 3 arguments to the `str_sub()` function.


```{r}
str_sub(words, 1, 9)
```
The first input is the string we want to get a substring from. The second input is where we want to start indexing the string, while the third input is where we want to end the indexing. Dataquest is 9 letters long, so our end index is 9.


1. Get the first 4 letters of the word "Dataquest" and assign it to the variable `first_four_letters.`
2. Get the last 2 letters of the word "Dataquest" and assign it to the variable `last_two_letters.`


```{r}
word <- "Dataquest"

first_four_letters <- str_sub(word, 1, 4)
last_two_letters <- str_sub(word, 8, 9)
```


## Handling Word Casing

One particularly common string manipulation task in data analysis is changing the column names of a dataset. As with other lessons, we'll use the `recent_grads` dataset to practice our skills. Below are the column names of `recent_grads`:


```{r}
recent_grads <- read_csv("recent_grads.csv")
colnames(recent_grads)

```
Notice that each of these column names start with a capital letter. [It's common practice to standardize the column names by turning everything into lowercase.]{color='red'} Having each letter in lower case makes them easier to type. It's a small detail, but it's good practice to incorporate into our analysis.

Instead of manually replacing the one letter for each string, we can turn to another function from `stringr` called `str_to_lower()`. This function just takes a character vector, and it will convert all of the letters to lowercase:

```{r}
str_to_lower(colnames(recent_grads))
```

There's a reverse function to` str_to_lower() `that converts everything to uppercase: the `str_to_upper()` function. There are less situations where we might want to convert everything into uppercase, but knowing that the functionality is still there can help.

1. Convert the column names of the `recent_grads` dataset to lowercase and assign them to the vector `lower_case_colnames.`

2. Using the function `str_to_lower()` doesn't directly change the column names of the tibble, we actually need to reassign `colnames(recent_grads)` in order to do this. Using `lower_case_colnames`, reassign the column names of `recent_grads` to be all lowercase.



```{r}
lower_case_colnames <- str_to_lower(colnames(recent_grads))

colnames(recent_grads) <- lower_case_colnames # change all column names
```
## String Trimming & Padding

Another common string manipulation task is to take raw strings and remove unnecessary whitespace. This process, known as trimming, is common in tasks like web scraping where the string data comes in the form of HTML and CSS. For example, take the following string:


```{r}
padded_string <- "     Dataquest      "
```

`padded_string` has extra spaces that come before and after the word "Dataquest". In order to trim this whitespace, `stringr` provides a neat function in the form of the `str_trim()` function. The `str_trim()` function takes any character vector and removes all of the whitespace that comes before and after.

```{r}
str_trim(padded_string, side = "both")
```

The `side` input of the `str_trim()` function defaults to `"both"`, which removes the whitespace from both sides. We may also input `"left"` or `"right"` if we only want to trim one side.

There are other times where we might want to perform the opposite of trimming, which is known as **padding.** Padding is useful in cases where we need to standardize a bunch of strings to a common length for use in a function. The `stringr` function to use for padding is the `str_pad()` function. In order to use the `str_pad()` function, [we have to know in advance how long we want the resulting string to be.]{color='red'}

```{r}
str_pad("Dataquest", width = 20, side = "both", pad = " ")
str_pad("Dataquest", pad = "k", 21)
str_pad("Dataquest", pad = "k", 21, "both")
# only one letter or number can be added in the pad section and without adding side, it assumes the letter and number to be on the left side of the string

```


The number `width = 20` defines how long we want the output of the `str_pad()` function to be. The `side` input helps tell `str_pad()` [how to distribute the extra whitespace that's being added to the string, not how much whitespace to add to each side]{color='red'}. If our `width` is shorter than the word we give it, then no padding will be added to the word. The `pad` keyword lets us specify the exact character we want to use to pad the word. The `str_pad()` function defaults to using a space.



The `recent_grads` dataset has been loaded in. It turns out that the `major_code` column is formatted incorrectly and actually has leading zeroes. For example, the number "2419" should actually be "0002419". We'll use what we know now to correct this column.

1. Create a new column in `recent_grads` called `formatted_major_code.` Take the `major_code` column and correctly format it according to the description above.



```{r}
recent_grads <- recent_grads %>%
  mutate(
    formatted_major_code = str_pad(major_code, 7, pad = "0")
  )
# This can be understood as, turning the existing 4 digit code into a 7 digit code, adding zero on both side, and  forcing the 0 to be added on the left side of the code
```


## String Splitting


All of the functions we dealt with so far have only looked at single words. Often times, we'll encounter entire sentences. Sentences are still treated as a single character vector, but there are some other operations that we can use with them. For example the following sentence:

```{r}
sentence <- "The stringr library is essential to string manipulation."
```

From R's perspective, the `sentence` variable just contains one long string. From our human eyes though, we see a sentence composed of multiple words. Fields like natural language processing often try to take these sentences and break them down into their component words. Instead of one long sentence, we would need a character vector where each element is an individual word. `stringr` provides the `str_split()` function for this purpose:

```{r}
str_split(sentence, " ")[[1]]
```

The output of the `str_split()` function is a list. In the example above, `sentence` only contains one string, so the output list only contains one element: the split `sentence.` [If we actually wanted to access this vector itself, we need to use double bracket notation, as in the following:]{color='red'}

From here we can access the different elements of the character vector using single bracket notation, since that's how we access things in vectors. If this gets to be a little confusing, it might be easier to assign a variable with a more helpful name to distinguish which data structure we're working with.

```{r}
# Store the first element in the str_split list
sentence_words <- str_split(sentence, " ")[[1]]

# Access elements in the vector
sentence_words[1]

sentence_words[1:3]
```

`str_split()` needs to be told what character it should split a sentence by, which we specify in the second input. Naturally, words are separated by whitespace, so that's what we use here (`" "`). We may also use `"-"` for things like phone numbers.



1. We provided a sentence with `input_sentence.` Use the `str_split()` function to split it into a character vector. Assign the character vector itself to the variable `output1.`

2. Take `output1` and get the first 4 words from it. Assign these words to the variable `output2.`


```{r}
input_sentence <- "You'll need to split this sentence."

output1 <- str_split(input_sentence, " ")[[1]]
output1
output2 <- output1[1:4]
output2
```

## String Concatenation

There are other times where we might want to combine multiple words into one sentence instead. We call this operation `string concatenation`. The `str_c()` function does this for us: it takes in a character vector of multiple strings and returns a single-element character vector with the combined sentence.

```{r}
words <- c("String", "concatentation", "via", "function")
str_c(words, collapse = " ")
```

The `collapse` keyword is what tells R what character splits up the sentence. Another word for this is **delimiter.** We use a single space `" "` for the `collapse` argument, so we can see in the resulting sentence that each of the words is separated or delimited by a single whitespace.

In general, string splitting is a much more common operation than string concatenation, but it's important to be aware of how to do both.

1. We provided a character vector with the `input_words` variable. Use the `str_c()` function to combine it into a single sentence. Assign this character vector itself to the variable `sentence.`


```{r}
input_words <- c("This", "set", "of", "words", "should", "be", "combined")
sentence <- str_c(input_words, collapse = " ")
sentence
```



## Regular Expression

The last few topics of this lesson involves searching strings. String search is one of the most common tasks that we can perform with strings. If you ever used `CTRL + F` or `Command + F` to try to find a particular word in your search engine, then you used string search.

The technical term for searching for specific strings is **regular expression**, or **regex** for short. Regular expression is a large topic to cover, so we'll only cover the fundamental concepts needed to understand how to use some essential `stringr` functions. In general, most people use regular expression for word search, but it can be used for much more powerful purposes. Sophisticated regular expression to search and detect phone numbers, which is much harder than it sounds.

With regular expression, we have **two ingredients:** 
1. some text that we want to search through
2. [a specific search pattern that we want to look for.]{color='red'} **A search pattern is just a general term for a specific string or set of characters we want to find.** When we are supplying a specific word into` CTRL + F` or `Command + F` to find a word in your search engine, we are giving it a search pattern to look for. We'll see this pattern on the next two screens, so it's good to know about coming into them.

## String Detection

On the last screen, we introduced the idea of regular expression. Regular expression is used to search for specific patterns (words, characters, etc.) in a set of text. On this screen, we'll learn how to answer the question,** "does this string contain a particular substring we want?"**

Take for example the following sentence:
```{r}
review <- "I really enjoyed this product, and I thought it was great for the price."
```

Let's say that we have many reviews like the one above and we want to try to figure out how much people like the product. Looking at the review, we can tell it's favorable because words like "enjoyed" and "great" indicate that the user liked it. Maybe we can try to detect positive words as a way to measure how many reviews were good. To answer our question, we can use the `str_detect()` function.

```{r}
str_detect(review, "great")
```
The text we want to search through is in the variable `review`, and the search pattern is "great". Since the word "great" is contained within the `review` sentence, the `str_detect()` function returns TRUE.

It's important to note specifically what the `str_detect()` function is doing. From our perspective, the function seems like it's just looking for the word great, but it's more subtle than that. [It's really just checking if the substring "great" is contained in the string `review.`]{color='red'} This subtly can become a problem if smaller words are contained within longer words.

Let's say that we want to look for the word "pro" in the `review.` This is what `str_detect()` function will return:


```{r}
str_detect(review, "pro")
```
The substring "pro" is contained within the word "product", but if we don't understand what `str_detect()`is doing, we would be mistaken and think the word "pro" appears in the review.



1. We want to do an analysis on all of the majors that contain the word "ARTS". Create a new column called `is_arts` in the `recent_grads` dataset that is `TRUE` when `Major` contains the word "ARTS" in it or `FALSE` if it doesn't.


```{r}
recent_grads <- recent_grads %>%
  mutate(
    is_arts = str_detect(major, "ARTS")
  )
```

## String Replacement

The last string manipulation function we'll cover is string replacement. String replacement is almost like string detection, but it takes it one step further. In addition to detecting a particular search pattern, string replacement takes that pattern and replaces it with another one.

Let's say that we're dealing with more reviews and we're still trying to check if the reviews are good or not. We come across the following review:
```{r}
review2 <- "I really enjy codnig in R and wnt to lrn more."
```

Suppose that we're looking for the word "enjoy" to determine if a review is good or not. If we were to use this review unaltered, we would mistakenly miss a good review. Before analyzing this review, we decide to replace all of the misspelled words. The `str_replace()` function will help us out on this:

```{r}
str_replace(review2, pattern = "enjy", replacement = "enjoy")
```

The `str_replace()` function takes three inputs: the text we want to search through, the search pattern we want to change (`pattern`), and lastly, the word or characters we want to use to replace the pattern (`replacement`). In the code above, we are replacing the misspelled "enjy" with the proper "enjoy".

String replacement can also be used to remove text as well, since deleting text can also be interpreted as replacing text with "nothing". This is extremely useful if we want to remove certain characters like punctuation or numbers. Let's say that we only want to keep the first clause in `review2`, then we would do the following:

```{r}
str_replace(review2, pattern = " and wnt to lrn more", replacement = "")
```

If the `str_replace()` function doesn't find a match in the string, then no replacement will happen and the string will be returned to its original form. [One limitation of the` str_replace()` function is that it will only replace the first instance of a pattern.]{color='red'} We can see this in the following:
```{r}
review3 <- "I want to lrn R, and I definitely wnt to lrn more."

str_replace(review3, pattern = "lrn", replacement = "learn")

```


Notice that the second misspelled `lrn` has not been fixed. [In these cases, you should use the `str_replace_all()` function.]{color='blue'} The syntax and keywords are similar to `str_replace()`, but the key difference is that `str_replace_all()` will replace all pattern matches instead of just the first one it sees.

```{r}
review3 <- "I want to lrn R, and I definitely wnt to lrn more."

str_replace_all(review3, pattern = "lrn", replacement = "learn")
```


1. We want to shorten each instance of the word "Engineering" in the `Major_category` column with the abbreviation "`Engr.`"Modify the `recent_grads` dataset so that the `Major_category` column incorporates this change.

```{r}
recent_grads <- recent_grads %>%
  mutate(
    major_category = str_replace(major_category, "Engineering", "Engr.")
  )
# This line of code also retains the original column and changes the format without adding extra one. 

```

# **2. Data and Time Manipulation**

In this lesson, we'll cover one last fundamental skill in data analysis; date and time manipulation. Another lesson covers the use of dates and times in R.

Dates and times appear everywhere in an analysis context. Businesses want to see if a new advertising campaign has made a significant effect on their sales, so they would look for patterns before and after the campaign. Accelerometers in your phone keep track of your activity through time, so you can analyze how active you are throughout the day.

R doesn't have a built-in data type for dates and times, but it has well established functions that smooth the process of using them. Throughout this lesson, we'll use the `lubridate` package.

## Data Representation

Throughout this course, we'll distinguish between dates and times. **We'll refer to dates **as time on longer scales, like years, months and days.**The phrase "times" refers** to shorter scale of time, down to hours, minutes and seconds.

There are two main ways that dates and times can be represented in R. The first way is through strings. Strings can be complicated because dates and times can be written in many different ways. The way a date is written can change depending on the country you live in.

For example, dates are typically written in the form "YEAR/MONTH/DAY" in most countries, but they are written in form "MONTH/DAY/YEAR" in the United States. Some countries include leading zeros in their dates, like "04/21" for April 21st, but others may omit it. This diverse representation can make handling dates difficult, especially if you're dealing with different formats.

This is why packages like `lubridate` are essential to handling dates and times. The `lubridate` package is a part of the tidyverse and is dedicated to handling this data type. There are specific functions to handle different strings and correctly capture the date given a search pattern. This process is called parsing a date. We'll look at two examples to `lubridate`'s parsing functions:

```{r}
date1 <- "20/04/21"
date2 <- "04-21-20"
```
These two strings refer to the same date, but are different representations of it. `lubridate` has a series of functions that let you convert both strings to the same standard date. Each follows the same naming pattern. The first one is in the format "YEAR/MONTH/DAY", so we can use the `ymd() `function to do the conversion.

```{r}
ymd(date1)
```

The second one is in "MONTH/DAY/YEAR" format, so you'd have to switch around the letters: the `mdy()` function is more appropriate here.

```{r}
mdy(date2)
```

You can see that the two functions correctly parse the date if you know its structure. You can also see that the dates are correct even if the dividing characters are different between the two. As you see different dates in your data, you can find the appropriate function to do the conversion. From an initial look, it seems that the output of these functions are still just strings, but there's some extra functionality there that is useful in later screens.



There are two given dates in the console. Use the appropriate function from `lubridate` to convert it into a proper date.

Using `date1`, return the correct date and assign it to the variable `date_standardized1.`
Using `date2`, return the correct date and assign it to the variable `date_standardized2.`



```{r}
date1 <- "01011970" # should be January 1, 1970
date2 <- "2019-03-04" # should be March 4, 2019

date_standardised1 <- print(mdy(date1))
date_standardised2 <- print(ymd(date2))

```

## Time Representation

Now that we know how to parse dates, you'll be glad to know that `lubridate` extends these functions to account for time as well. For the most part, we only deal with hours, minutes and seconds when dealing with time, so we'll focus on these aspects.

We'll look at how to parse the following two variables correctly:

```{r}
date1 <- "20/04/21 13:30:00"
date2 <- "04-21-2020 01-30 PM"
```

These two dates are similar to what we saw on the last screen, but now they incorporate time information. These dates are different representations of April 21 2020, 1:30 PM.

On the last screen, we saw that functions like `ymd()` and `mdy() `can be used to handle different representations of a date. `lubridate` extends these functions to handle time by using `h` to denote hour, `m` to denote minutes and `s` to denote seconds.

```{r}
ymd_hms(date1)
```

`lubridate` distinguishes between the dates and times with an underscore. The output of the `ymd_hms()` function is similar to the `ymd()` function, but it has added the extra information on time. **The three letter acronym "UTC" at the end stands for Coordinated Universal Time**, and it represents the time zone for the date and time. Time zones add an extra complexity to handling dates and times, but we'll see that `lubridate` simplifies handling them later in the lesson. If no timezone is specified in the date/time parsing functions, `lubridate` assumes that the timezone is UTC.

If we wanted to change the timezone, we would need to specify it in the `tz` input of the parsing functions. Let's say that the date and time for `date2` actually comes from New York, so we can adjust accordingly.

```{r}
mdy_hm(date2, tz = "America/New_York")
Sys.timezone()
```

Notice here that the function lacks the `s` for second since `date2` has no information on seconds. The family of date/time parsing functions is large and can account for a wide array of situations.

If you are unsure about your own time zone, you can use the `Sys.timezone()` function into your R console, and it returns which one your system uses.


There are three given dates and times in the console. Use the appropriate function from `lubridate` to convert it into a proper date-time combination.

1. Use `datetime1`, return the correct date and assign it to the variable `datetime_standardized1`.
2. Use `datetime2`, return the correct date and assign it to the variable `datetime_standardized2`.

```{r}
datetime1 <- "01-01-1970-00-00-00" # should be January 1, 1970 at midnight
datetime2 <- "2019-03-14 1:59 AM" # should be March 14, 2019, 1:59 AM

datetime_standardised1 <- mdy_hms(datetime1)
datetime_standardised2 <- ymd_hm(datetime2)
datetime_standardised1
datetime_standardised2
```


## Unix Representation

While most of the time, we'll see dates and times formatted in terms of strings, there is another important representation that needs to be mentioned. It is actually possible to represent dates and times as a number, and this representation is called Unix time. Unix time was created to make dates and times more computer friendly.

[To describe time numerically, Unix time describes the number of seconds that have passed since January 1, 1970 at midnight in UTC.]{color='red'} The date January 1, 1970 is usually what's used as an origin, or Unix epoch, but others can be specified. In any case, Unix dates and times are always in reference to a starting date.

If you want to know what the Unix time is right now, you can write out the code:

```{r}
now <- Sys.time() # Gives current calendar date and time as a string

now %>% ymd_hms() %>% as.numeric()
```


The `Sys.time()` function outputs the current time as a string, but this needs some formatting. In order to see a Unix representation of a date, you need to convert the date/time string into an actual date via the `ymd_hms()` function or one of its relatives. Underneath the hood, `lubridate` knows to handle dates and times in terms of Unix time and shows them as human-readable strings. From there, we can take the output of `ymd_hms()` function and convert it back into a number through the `as.numeric()` function. At the running of the above code, more than 1.5 billion seconds have passed since midnight January 1, 1970.

String and Unix representations are the main ways you will encounter dates and times. With `lubridate`, we get the benefits of both representations, getting the readability of strings and the calculation-readiness of numbers. Now that you're familiar with how they appear, we can explore how to manipulate them in analysis.


1. In the console, take the current date/time and convert it into Unix time.
2. Try experimenting with different dates too!


```{r}
Sys.time()
Sys.Date()
test <- "2022-05-31 13:30:31" # remember to put on the apostrophe
test %>% ymd_hms() %>% as.numeric()
```

## Component Extraction

When working with dates and times, we'll only need a single part of it depending on the analysis. Sometimes, we may only want the year of a date or maybe the hour. Once we've taken dates and converted them into a date object with `lubridate`, we can use other functions to extract the components we need.

Let's start with a given date:
```{r}
date <- ymd("2020-04-21")
```


If we wanted to extract the year from the `date` variable, we could use the `year()` function.

```{r}
year(date)
month(date)
day(date)
hour(test)
minute(test)
second(test)
```

Similarly, there is the` month()` function and the `day()` function that perform the same function for the corresponding aspect of the date. There are even functions that extract the time components of a date-time (i.e.` hour()`, `minute()`, `second()`).

There are other specialized functions that can give you even more information for the specific day. Many analyses rely on looking at days of the week. [The `wday()` function takes in a date, and it returns the day of the week that date took place on.]{color='red'} It returns a number between 1 and 7, but you can change it to return a string as well:

```{r}
wday(date)

wday(date, label = TRUE)
```

Other types of analyses need to know the day of the year. For example, February 1st would be considered the 32nd day of the year. [To get the day of the year for a particular date, you can use the `yday()` function.]{color='red'}

```{r}
yday(date)
```


We are given an initial date/time. Take this date and extract the desired component with the correct function.

1. What month does this date take place on? Assign your answer to the variable `answer_month.`

2. What day of the week does this date take place on? Assign your answer to the variable `answer_day_of_week.`
   For this answer, we want the day of the week as a string, not a number.

```{r}
input_date <- "2020-11-13 13:13:13"

answer_month <- month(input_date)

answer_day_of_week <- wday(input_date, TRUE)

answer_month
answer_day_of_week
```



## Time Span Calculation

A benefit to working with Unix time is that it makes calculating spans of time easier. Using `lubridate`, we can make calculations like the following:

```{r}
ymd("2020-04-21") - ymd("2020-04-20")
```



Underneath the hood, R uses the Unix representations of both of these dates and performs the numerical calculation. From the Unix time difference, R calculates how many day's worth of seconds it is and returns this to the user. The end result is a smooth process that allows a user to "subtract" dates from each other and get a span of time.

Although the sentence `Time difference of 1 days` was shown on the console, the actual calculation returns a number. If you were to store the calculation in a variable, you would see that it just contains a single `1`.

[The sign of this number is important. Since it is positive, we would interpret it as moving forward in time. This makes sense since April 21 must come after April 20. ]{color='red'} If we were to flip these two dates, then we would get a negative number, representing moving backward in time. This nuanced interpretation is easy to forget but important to remember in data analysis.

These calculations work even for more fine-grained calculations involving hours, minutes and seconds, as shown below:



```{r}
ymd_hms("2020-04-21 17:00:00") - ymd_hms("2020-04-21 08:30:00")
```


R takes the two date/times and performs the same calculation with Unix time. Then, it takes the largest time denomination, minutes, and returns a value based on that.

1. Store the current date and time into a variable named now. Recall you can use the Sys.time() function to capture this.
2. How much time has passed since March 1st, 2015 to the time stored in now? Assign your answer to the variable days_since_founding.


```{r}
now_d <- Sys.Date()
days_since_founding <- ymd(now_d) -ymd("2015/03/01")
days_since_founding

# or 

now_t <- Sys.time()
days_since_founding <- now_t - ymd_hms("2015-03-01 00:00:00")
days_since_founding
```


## Duration and Periods

On the last screen, we looked at how `lubridate` can handle the calculation of time spans. Given a start and end date, `lubridate` uses Unix time to calculate how much time has passed between the two.

There are other cases where you have a start date, and you want to know what the end date is after a given amount of time. [This type of calculation is much more nuanced since we have to account for possible carryover between months and the possibility of daylight savings.]{color='red'} To account for these complexities, `lubridate` has created several functions that allow you to account for these extra details. These functions create two different types of time spans that we can add to dates: Durations and Periods.

Durations record a time span in the exact number of seconds that make it up. We can use the `duration()` function to create a Duration:


```{r}
dur <- duration(day = 1, hour = 1, minute = 30)

dur
```

The largest time scale available to make a duration is the `week.` After we create a Duration object, we can add it to different start dates to see what the corresponding end date would be.


```{r}
ymd("2020-04-21") + dur
```


Durations are useful when we want to be more precise with our time calculations. With durations, each second is treated the same. However, there are times where this isn't the case, like with month carryover, leap years or daylight savings.[ Durations do not correctly account for these factors, so we would need to look at Period objects for this purpose.]{color='blue'}

We can create Periods in a similar way to Durations with the `period()` function.

```{r}
per <- period(years = 1, months = 1, days = 1) # one difference to note is that in period function, the time should be written in plural
```

**Unlike Durations, we can specify longer time spans with Periods since they are able to account for different time conventions. In terms of calculation though, Periods and Durations are indistinguishable.**

```{r}
ymd("2020-04-21") + per
```


[**As a rule of thumb, if you don't need to worry about things like daylight savings, use Durations. If you do, use `Periods.`**]{color='red'}

Provide a start date in the variable `start.`

1. Create a Duration object of 5 days and 12 hours. Add this duration to `start` and assign the resulting end date to the variable duration_end.

2. Create a Period object of 1 month and 1 day. Add this period to `start` and assign the resulting end date to the variable `period_end.`


```{r}
start <- ymd("2020/05/01")

dur <- duration(day = 5, hour = 12)

duration_end <- start + dur

duration_end

per <- period(months = 1, days = 1) 

per_end <- start + per

per_end

# or 

start <- ymd("2020/05/01")
duration_end <- start + duration(day = 5, hour = 12)
period_end <- start + period(month = 1, day = 1)

```

## Time Zone Manipulation 

We've learned a lot about manipulating dates and times using the `lubridate` package. We'll wrap up this lesson by covering the topic of handling time zones. Most analysis you'll do with dates and times will happen in only one time zone, which helps standardize the time in the dataset. However, you may not be so lucky at other times if your analysis contains rows from multiple time zones, as would be the case if your data comes from multiple states or countries.

In these cases, you would need to convert time zones. As with the other operations we've learned throughout this course, `lubridate` offers a few functions that smooth the process of this conversion. We'll start with an example date and time:

```{r}
example <-  ymd_hms("2020-05-01 12:00:00")

example
```

You may recall from a previous screen that dates and times default to the UTC timezone if you do not specify a timezone in functions like `ymd_hms()` function. [In order to convert this time into another time zone, you can use the` with_tz()` function.]{color='red'} For example, if we wanted to convert the `example` time into Pacific Daylight Time (PDT), we would need to use the timezone `"America/Los_Angeles"`.


```{r}
with_tz(example, tz = "America/Los_Angeles")
```

This answer lines up with our intuition since PDT is actually seven hours behind UTC. In order to use the `with_tz()` function correctly, you will need to know precisely what string corresponds to the time zone that you want to convert to. To get a detailed list of all the possible timezones that are accepted by the` with_tz()` function, you can use the `OlsonNames()` function. The `OlsonNames()` function returns a long character vector of all the possible timezones. We show a partial vector below.



```{r}
OlsonNames()[1:10]
```

Notice that the `OlsonNames()` function needs to have the empty `()` parentheses in order to access the character vector. The `[]` square brackets access the elements in the returned character vector.


# **3. The Map Function**

## Introduction

In the last course, we talked about the importance of vectorization to data analysis. Vectorization allows us to quickly create new columns in our tibbles from existing columns in our data, as seen through the `mutate()` function. As you've learned new programming skills, we tried to teach you functions that help vectorize operations of interest. An example we saw is the `if_else()` function, which vectorizes the `if` statement on a specified column.
![](https://dq-content.s3.amazonaws.com/514/code-flow-3.png)
In this lesson, we'll learn how to vectorize a function. As we know them, functions take inputs, perform a calculation on them and then return an output. Currently, we have no way of taking each of the values in a tibble column and putting them through a function to get a column of outputs. Unfortunately, this process is more complicated than passing in a single column into a function and getting back an output column. This operation is extremely common in data analysis, but it requires more explanation and depth compared to what we covered so far. This lesson will combine the concepts of vectorization and custom functions, and there's a lot of ground to cover. Learning this skill will greatly expand your capabilities as a programmer and analyst. Let's start!


## Introduction to The Data

To really see the power of vectorization, we'll be analyzing a dataset that lends itself well to this application. Our dataset is a collection of test scores of four different students. [Each student took five different tests for three subjects: writing, math and science.]{color='red'} Over the course of this lesson, we'll perform different analytical tasks that will require us to vectorize different functions.

We'll act as the teacher for these students. Given these scores, we need to calculate various summaries and values for each student. Let's have a quick look at the data below:

```{r}
student_scores <- read.csv("scores.csv")
glimpse(student_scores)
head(student_scores)
```

In addition to the writing, math and science scores, we also have an · column that describes how much extra credit they have for a corresponding math assignment. We'll need to take this column into account when calculating everyone's final averages. Notice too that each of the scores are all `character` vectors. We'll need to handle this in the data cleaning as well.

1. The dataset is contained in the `scores.csv` file. Load it into a variable called `student_scores` so that we can move forward and analyze it.

## Preparing Our Function 

The first problem we need to address with the dataset is the fact that each of the students' scores are written as strings. Preferably, we would want them to be numbers we can use in calculations. This gives us a perfect opportunity to try to vectorize a function since we'll need the entire column of strings to be converted into numbers. Once we create this function, we can vectorize it over all of the scores to create properly formatted columns.

Here's the same preview from the last screen, so you can have the format of the data in mind.

We'll slowly build up to the vectorization, but we'll focus on creating the function first before moving on.

We provided a string in the variable `percent_string`. We would like to convert it into numerical form.

1. Create a function called `format_score()` that:
- Takes in a single string as an input.
- Removes the `%` sign from the string.
- Converts the string into a number using the `as.numeric()` function. This useful function takes in a string and will convert it into a number if it resembles a number.
- Outputs that number (e.g. The string "74%" should be converted to the number `74`.)

2. Pass `percent_string` into the `format_score()` function and assign the output to the variable `converted_string`.



```{r}

percent_string <- "74%"
format_score <- function(score) { # this part defines the function itself
  fmt_string <- str_replace(score, "%", "")
  num <- as.numeric(fmt_string)
  
  return(num)
}

# The "score" inside the function represents a general variable that should be processed, which is passed into fmt_string first, then fmt_string is passed into num. 

# It can be understood as function g is a funciton of f. 
# Visually, it is format_score = function(score) = as.numeric[str_replace(score)] = num

converted_string <- format_score(percent_string)
converted_string
```


## The map Function

Now that we have our candidate function to vectorize, we must learn how to do so. That is, given a column of strings, how can we use our `format_score()` function on each of the values and, in return, get another column containing all of the individual outputs?

The diagram below illustrates how vectorizing a function might look like:
![](https://dq-content.s3.amazonaws.com/515/map-diagram.png)
As their name suggests, the `inputs` represent a series of values that will act as the inputs to our function. We made an example function with `add_one()` which takes a value, adds one to it and returns this result. The `outputs` represent a series of outputs that come from the results of inputs being put through the `add_one()` function. We currently don't know how to apply a function (e.g. `add_one()` or `format_score()`) to a series of values, but we'll learn how to do so on this screen.

[Enter the `map()` function. `map()` is from the purrr package, which is another central package in the `tidyverse.` ]{color='red'} The job of `map()` is to vectorize functions, as shown in the diagram above. Before we can use the `map()` function, we need to discuss its input and output and how they relate to tibbles.

The `map()` function takes two inputs:

1. a vector or list
2. [a function to apply on this vector/list.]{color='red'} `map()` will take each element of the input vector or list, apply the function to each element, and will return a list. If we code the diagram above, we get:


```{r}
# Input vector
inputs <- 1:5

# Function to vectorize
add_one <- function(value) {
  return(value + 1)
}


outputs <- map(inputs, add_one)

outputs
```

Checking the type of `outputs`, we can confirm that it's a list.

```{r}
typeof(outputs)
```

As you might recall, a list can be indexed by either a number or a string using double bracket notation. The first element in the list, indexed as `map_result[[1]]` contains the output of `add_one(1)`, and so on. It's important to remember exactly what the output of the` map()` function is. We may accidentally assume that `map()` returns a vector and use the output as one, but we would get errors. Before we continue our discussion, practice using the `map()` function.

We provided a `format_score()` function for you to use. You may also use the function you created on the last screen.

1. Using the given vector `input_scores`, map the `format_score()` function on all of the values in this vector. Assign the output to the variable `output_scores.`
2. After creating your `output_scores` variable, take third element of `output_scores` and assign it to the variable `third_element`.

```{r}
input_scores <- c("83%", "29%", "76%")

format_score <- function(score) {
  fmt_string <- str_replace(score, "%", "")
  num <- as.numeric(fmt_string)
  
  return(num)
}

output_scores <- map(input_scores, format_score)

third_element <- output_scores[[3]]
third_element
```


## Creating New Columns With map

On the last screen, we learned how to use the `map()` function to vectorize the `format_score()` function we made to clean up our student data. We saw that the `map()` function outputs a list, but it's not entirely clear how this will allow us to actually convert the `student_scores` into the format we need.

The answer is thankfully easy for us to implement as programmers. We can actually just use the `mutate()` function to directly create the new columns with the `map()`. What matters is that `map()` creates a list that has the same number of elements as the number of rows in the data. This output list will be used as the new column in the data!

What this boils down to is just passing another column in the dataset as the input vector/list into the `map()`, just as we saw on the last screen. As an example, we'll clean the `writing_score` column using the `format_score()` function.


```{r}
format_score <- function(score) {
  fmt_string <- str_replace(score, "%", "")
  num <- as.numeric(fmt_string)

  return(num)
}

student_scores <- student_scores %>%
  mutate(
    new_writing_score = map(writing_score, format_score)
  )
# this method follows the same logic in section 1, string replacement

student_scores <- student_scores  %>%
  mutate(
  writing_score = str_replace(writing_score, "%", "")
  )
```

The above code creates a new column `new_writing_score` that cleans the `writing_score` column using the `format_score()` function. We can check the columns in `scores` to confirm that our new column is a part of the data:

```{r}
colnames(student_scores)
```

If we try to inspect the new_writing_score column, we'll see something you might not expect:

```{r}
# Output shortened for readability
student_scores$new_writing_score[1:3]
```

[Remember that the `map()` function returns a list, so this is what we see in the new column. Ideally, we would only want to see a vector of values instead of a list.]{color='red'} While there are more elegant solutions to convert the `map()` output into a vector, right now we can fix our problem with the `unlist()` function. As its name suggests, the `unlist()` function will convert a list into a vector, which is exactly what we need.


```{r}
student_scores <- student_scores %>%
  mutate(
    new_writing_score = unlist(map(writing_score, format_score))
  )

student_scores$new_writing_score
```


As we discussed before, the `map()` takes each value in the writing_score column and passes it into the `format_score()` function. After doing this for each value, it takes the result of the `map()` and assigns it to `new_writing_score.`

With this in mind, help clean the other two score columns in the `scores` dataset.


The `student_scores` dataset is loaded in, and we already cleaned the `writing_score` column.

1. Use the `format_score()` function to create a new column called `new_math_score` in the `student_scores` dataset. Use the `math_score` column as an input.
- Make sure to use the `unlist()` function to convert the result into a vector.

2. Similarly, use the `format_score()` function to create a new column called `new_science_score` in the `student_scores` dataset. Use the `science_score` column as an input.


```{r}
student_scores <- student_scores %>% 
  mutate(
    new_math_score = unlist(map(math_score, format_score)),
    new_science_score = unlist(map(science_score, format_score)))
```

## Two Input Variation of Map

On the last screen, we cleaned up the `score` columns in the dataset so that they would be in numerical format. On this screen, we'll discuss a limitation to the `map()` function and how to overcome this limitation.

Thankfully, the `purrr` package contains a whole family of `map()` functions for different situations. The `map()` function is designed to work with only one input, and its cousin the `map2()` function is designed to handle two inputs. We'll visualize a use case for `map2()` below, slightly adjusting our example from earlier.


![](https://dq-content.s3.amazonaws.com/515/map2-diagram.png)
In this case, there are two inputs (`inputs_first` and `inputs_second`). Likewise, the function we want to vectorize, `add_two_values()` has two inputs. We can use `map2()` to vectorize `add_two_values()` on `inputs_first` and `inputs_second.` Converting the diagram into code form, we have:


```{r}
# Two inputs vectors
inputs_first <- 1:5
inputs_second <- 6:10

# Function to vectorize
add_two_values <- function(x, y) {
  return(x + y)
}

outputs <- map2(inputs_first, inputs_second, add_two_values)

outputs
```
In the `student_scores` dataset, we have another column called `math_extra_credit.` This column is a string, and it represents the amount of extra credit a student earned on a particular math test. Depending on how much extra credit is earned ("None," "Low," or "High"), the student can increase their math score. We need to account for this when we calculate the math score. On this screen, we'll first develop the function we want to vectorize.


1. Create a new function called `add_extra_credit()`. It should take two inputs: the first one should be a number (representing a score) and the second one should be a string (representing an amount of extra credit)

- If the string is "None": Don't add any extra points to the number input.
- If the string is "Low": Add 1 extra point to the number input
- If the string is "High": Add 5 extra points to the number input

2. Using the given `input_score` variable, make sure that it works correctly with different inputs for the string.

- With a string of "None": Assign this output to `no_extra_credit_score.`
- With a string of "Low": Assign this output to `low_extra_credit_score.`
- With a string of "High": Assign this output to `high_extra_credit_score.`

**Hints:**

- There are two components to the function. The first part should figure out how many points to add to the input number. There's only three possible strings that the input can be, so control flow will work well here.
- Using the result from the control flow, add this value to the input number to get the answer you need
- Order matters when you give inputs to map2(). The first column that you give to map2() will go into the first input of the function. The second column will end up as the second input.

```{r}
# Very important 
input_score <- 50
add_extra_credit <- function(score, note) {
  if (note == "None") {
      points_to_add <- 0
  } else if (note == "Low") {
      points_to_add <- 1
  } else {
      points_to_add <- 5
  }
  return(score + points_to_add)
}

no_extra_credit_score <- add_extra_credit(input_score, "None")
low_extra_credit_score <- add_extra_credit(input_score, "Low")
high_extra_credit_score <- add_extra_credit(input_score, "High")

test_output <- map2(input_score, "High", add_extra_credit)
test_output
add_extra_credit(input_score, "High")
```
## Two Input Variation of map

On the last screen, we learned about the` map2()` function, a relative of the `map()` function that uses two inputs instead of one. We want to adjust a student's math score based on how much extra credit they've earned, so we developed a function that we'll vectorize to do this job.

Like with` map()`, we can use `map2()` to create new columns in a tibble. The syntax is similar, except that we need to input two columns instead of just one. The code below offers an idea of how to use the `map2()` function to create a new column in a dataset.

```{r}
example_tibble <- tibble(
  x = 1:5,
  y = 6:10
)
example_tibble

add_two_values <- function(x, y) {
  return(x + y)
}

example_tibble <- example_tibble %>%
  mutate(
    sum_column = unlist(map2(x, y, add_two_values))
  )
example_tibble
```

This code is similar to what we saw when we were first introduced to `map2()`, except that we are using tibble columns instead of vectors now. Like `map()`, `map2()` also creates a list, so we need to use the `unlist()` function to make sure that the new column is a vector. [Note that you must be careful about the order that you put the columns inside `map2()`.]{color='red'} The first column will be used as the first input in the function, and the second column will be used for the second input. Getting the order wrong will lead to unexpected errors.

Using the above code in mind, apply what you know about `map2()` to finally adjust the math score to account for extra credit.


We provided the `student_scores` dataset and all of the functions we used to convert the data into a more convenient format. We also provided an `add_extra_credit()` function to use on the dataset, but feel free to use the one that you've created.


1. Create a new column in the `student_scores` dataset called `adjusted_math_score.` This column should represent the math score that a student received on a test, accounting for the extra credit they got on the test.
- The `new_math_score` column contains the math score in number format.
- The `math_extra_credit` column contains the strings describing how much extra credit was earned.
- Make sure to use the `unlist()` function to convert the result from `map2()` into a vector.


```{r}
# remember to use the new math score, where % is removed
student_scores <- student_scores %>%
  mutate(
    adjusted_math_score = unlist(map2(new_math_score, math_extra_credit, add_extra_credit))
  )
```

## Even More map Variations

In this lesson, we only plan to cover just the `map()` function and `map2()` function for briefness. Of course, there is a `map()` variation that can take more than two functions. This function is the `pmap()` function. The p is supposed to stand for a variable amount of inputs. You can read more about how to use it in its documentation, but we won't cover it here. We may not use it here, but you may find some use for it in your own analyses in the future, so it's good to be aware of it.

The `map()` variations that we learned on this lesson both return lists. There are other` map()` variations that can return vectors instead. For these variations, you have to specify what kind of vector it will be, whether it is a character vector or a double vector. You'll learn more about these specific variations in a future lesson, but if you're curious you can also refer to the `purrr` documentation as well.


## Lists As Inputs

On the last screen, we learned how to use the `map()` function on a vector of values. We also know that `map() `can also take in an input list. As we'll learn on this screen, this will prove to be extremely valuable for us when we start using `map()` with tibbles.

Why is working with input lists much more powerful than input vectors? It's how tibbles are constructed by R. Although we work with them as if they are relational tables, they are actually a collection of lists! Each column in a tibble can be represented as a list. So, if `map()` can take in a list and output a list, it makes it perfect for vectorizing functions for our tibbles. We can also use `map()` on dataframes as well, but your focus should be on tibbles.

Here's an example of `map()` use with an input list:

```{r}
input_list <- list(
  c(1, 2),
  c(3, 4),
  c(5, 6),
  c(7, 8),
  c(9, 10)
)

output <- map(input_list, sum)
```


Each element in `input_list` as actually a vector. The first element is `c(1, 2)`, the second is `c(3, 4)`, and so on. In the above example, `map()` takes each of these vectors and applies the `sum()` function on all of them. Examining `output`, we can see each of the sums:

```{r}
output
```
This example is a good showcase of why lists are such a powerful data structure. So far, we worked with tibbles that contain single, simple data types, like a number or a string.

![](https://dq-content.s3.amazonaws.com/495/map-diagram-2.png)
More complicated lists like `input_list` can form more complex columns in a tibble, since lists can contain any R object, putting these lists into a tibble can make for extremely powerful analysis. These columns have a special name: **list-columns**. We'll learn more about how to use these special columns later, but for now it's good to know they exist. For now, we'll work with tibbles with single values in each cell, but it's good to know that R has these capabilities.
```{r}
input_list <- list(
  1:10,
  11:20,
  21:30, 
  31:40,
  41:50
)

averages <- map(input_list, mean)
averages
```
## Vectorising Summaries 
As we wrap up this lesson, we'll discuss another powerful way to vectorize functions. The functions we used in this course deal with one or two inputs and output a single value. In particular, we used the `map()` function to help us clean the `student_scores` dataset.

Another useful type of function that we might want to vectorize is the *summary function*, functions that help us describe data using just one value. One example summary value that we might calculate is an average or mean. Another example is the highest value in a dataset. Both the average and the maximum are summaries because they take many numbers and output a single value that describes a quality of the dataset. Summary functions are different from what we dealt with so far because they take multiples values as a single input.

Many times, a teacher will want to get a bigger picture of how the student is doing, so they'll need to look at the average score of each student instead of the scores themselves. Currently, we don't know how to vectorize summary functions, but we'll use two functions in combination to do this: the `group_by()` function and the `summarize()` function.

We learned about the `summarize()` function in the Working With Tibbles course, and we'll revisit it here. Without `group_by()`, `summarize()` will calculate the average score based on the whole dataset. In other words, it will calculate the average writing score across all the students and their tests.

```{r}
avg_score_by_student <- student_scores %>%
  summarize(
    avg_writing = mean(new_writing_score)
  )
avg_score_by_student
```
![](https://dq-content.s3.amazonaws.com/515/without_group_by.png)
The `mean()` function is what we use to calculate an average (also known as a mean) from a collection of numbers. The above code takes in all of the values in `new_writing_score` and calculates an average from it.

`group_by()` tells R that we want to look at the dataset in terms of different groups, instead of just a single block. If we use `group_by()` beforehand, we are subtly splitting up the data into different groups. Then, `summarize() `will work on each group of data. Below, we use `group_by()` to tell R that we want to calculate the average for each student's tests.

```{r}
avg_score_by_student <- student_scores %>%
  group_by(names) %>%
  summarize(
    avg_writing = mean(new_writing_score)
  )
avg_score_by_student
```

![](https://dq-content.s3.amazonaws.com/515/with_group_by.png)
The illustrations don't include every name in `student_scores`, but offer a helpful guide to what the code is doing. `avg_scores_by_student` results in a 5 by 2 tibble, one row for every name in the dataset. The columns are the variable you group on, and whatever summary columns you create in `summarize()`. This type of analysis is incredibly useful if you're trying to compare two or more groups that are contained in a dataset. In this example, we are comparing students' test scores.


1. Using `group_by()` and `summarize()`, create a tibble that contains the high scores for each student in each subject. Assign your tibble to the variable `high_scores_by_student.`
- Name the high score of the writing column to be `highest_writing.`
- Name the high score of the (modified) math column to be `highest_math.`
- Name the high score of the science column to be `highest_science.`

```{r}
high_scores_by_student <- student_scores %>% 
  group_by(names) %>% 
  summarise(
    highest_writing = max(new_writing_score),
    highest_math = max(new_math_score),
    highest_science = max(new_science_score)
  )
high_scores_by_student
```






















