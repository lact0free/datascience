---
title: "7. SQL Intermediate"
author: "Ricardo"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float: yes
    pandoc_args: ["--lua-filter=color-text.lua"]
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load the packages
library(tidyverse)
library(tibble)
library(readr)
library(ggplot2)
library(dplyr)
library(RSQLite)
library(DBI)
```

```{cat, engine.opts = list(file = "color-text.lua")}
Span = function(el)
  color = el.attributes['color']
  -- if no color attribute, return unchange
  if color == nil then return el end
  
  -- transform to <span style="color: red;"></span>
  if FORMAT:match 'html' then
    -- remove color attributes
    el.attributes['color'] = nil
    -- use style attribute instead
    el.attributes['style'] = 'color: ' .. color .. ';'
    -- return full span element
    return el
  elseif FORMAT:match 'latex' then
    -- remove color attributes
    el.attributes['color'] = nil
    -- encapsulate in latex code
    table.insert(
      el.content, 1,
      pandoc.RawInline('latex', '\\textcolor{'..color..'}{')
    )
    table.insert(
      el.content,
      pandoc.RawInline('latex', '}')
    )
    -- returns only span content
    return el.content
  else
    -- for other format return unchanged
    return el
  end
end
```

# 1. Joining Data in SQL

## Introducing Joins

In the SQL Fundamentals course, our data source was a single table.
Often, we'll have multiple tables in one database that are related in
some way. In this course, we'll learn how to combine information from
different tables. Like the SQL Fundamentals course, we'll use SQLite
throughout this course.

In this lesson, we'll return to the dataset we used in the guided
project from the SQL Fundamentals course: the CIA World Factbook
(Factbook) database. The table we worked with was called `facts`, and
each row represented a country from the Factbook. Here are the first
five rows of the `facts` table:

In addition to the `facts`, we'll also be working with another table
called `cities` which contains information on major urban areas from
countries in the Factbook. These are the first five rows of the `cities`
table.

-   `id`: Unique ID for each city.
-   `name`: Name of the city.
-   `population`: Population of the city.
-   `capital`: Whether the city is a capital city; `1` if it is, `0` if
    it isn't.
-   `facts_id`: ID of the country, from the `facts` table.

In order to combine information from two different tables, we assume
that there is some piece of information that is shared between them.
Here, we can see that the `facts_id` column in `cities` is what connects
us to a particular country ID in `facts`. The diagram below illustrates
this link between the two tables. In particular, this diagram has a
special name: a schema diagram. Schema diagrams help us show how the
tables within a database are interrelated and on what columns they are
related by.

![](https://dq-content.s3.amazonaws.com/371/schema.svg)\

Here, we can clearly see the link between the `id` column of the `facts`
table and the `facts_id` column in the `cities` table.

Now that we know how these two tables are related, we can start tuning
our queries to combine data from both of them. When we combine two
datasets in SQL, we say that we join them. The easiest way to join data
using SQL is with an inner join. The syntax for an inner join is:

```{r}
# SELECT [column_names] FROM [table_name_one]
# INNER JOIN [table_name_two] ON [join_constraint];
```

The result doesn't read clearly into plain English, but there are two
clauses at work here. The first is the `SELECT` clause, which you should
be familiar with from SQL Fundamentals. The second, the `JOIN` clause,
is made up of two parts:

-   The `INNER JOIN` statement tells the SQL engine the name of the
    table you wish to join into your query and that you wish to use an
    inner join.
-   The `ON` statement, which tells the SQL engine what columns to use
    to join specific rows together.

Joins are usually used in a query after the `FROM` clause. The query
below is a basic inner join where we combine the data from both of our
`facts` and `cities` tables.

```{r}
# set up connection with database
conn <- dbConnect(SQLite(), "factbook.db")
```

The column `cities` is denoted after `INNER JOIN` to indicate that this
is the table from which we want to join. The condition,
`ON cities.facts_id = facts.id`, describes which columns in either table
to match to each other. In order to distinguish between which columns
are used in which tables, we use the following syntax:
`table_name.column_name`.

```{r}
# pull facts data
query <- "SELECT * FROM facts"
result <- dbSendQuery(conn, query)
facts <- dbFetch(result)
dbClearResult(result)
```

```{r}
# pull cities data
query <- "SELECT * FROM cities"
result <- dbSendQuery(conn, query)
cities <- dbFetch(result)
dbClearResult(result)
```

Something to keep in mind here is that the `SELECT *` will act slightly
differently from what you are used to. Instead of just grabbing all the
columns from `facts`, it will also give all the columns in `cities`
since we are joining from it. Here is the result of this query:

```{r}
query <- "SELECT * FROM facts
INNER JOIN cities ON cities.facts_id = facts.id"
result <- dbSendQuery(conn, query)
joined <- dbFetch(result)
head(joined)
dbClearResult(result)
```

This query gives us all columns from both tables and every row where
there is a match between the `id` column from `facts` and the `facts_id`
from `cities`, limited to the first five rows. We'll look at how the
join itself works in detail in a moment, but before that, we'll practice
writing our first join.

Write a query that returns all columns from the `facts` and `cities`
tables.

-   Use an `INNER JOIN` to join the `cities` table to the `facts` table.
-   Join the tables on the values where `facts.id` and `cities.facts_id`
    are equal.
-   Limit the query to the first 10 rows.

```{r}
query <- "SELECT * FROM facts
INNER JOIN cities ON cities.facts_id = facts.id
LIMIT 10;"
result <- dbSendQuery(conn, query)
dbFetch(result)
dbClearResult(result)
```

## Understanding Inner Joins

We've now joined the two tables to give us extra information about each
row in `cities`. We'll dedicate this screen to understanding how an
inner join works.

An inner join only includes rows from both tables that have a match as
specified by the `ON` clause. The diagram below illustrates the result
of the query from the last screen:
![](https://dq-content.s3.amazonaws.com/371/inner_join.svg)\

If we were to think about the collection of all IDs from `facts.id` and
from `cities.facts_id`, an inner join works by selecting all of the rows
from `facts` where an ID was in both `facts.id` and `cities.facts_id`.
This is easily represented as a Venn diagram:

![](https://dq-content.s3.amazonaws.com/371/venn_inner.svg)\

In the SQL fundamentals course, we learned how to use aliases to specify
custom names for columns:

```{r}
# SELECT AVG(population) AS AVERAGE_POPULATION
```

We can also create aliases for table names to make queries with joins
easier to both read and write. Our query from the last screen can be
rewritten as:

```{r}
# SELECT * FROM facts AS f
# INNER JOIN cities AS c ON c.facts_id = f.id
```

Our aliases can actually be combined with wildcards. If we wanted to
select all of the columns from `cities` in the `SELECT` portion, we
would write `c.*`. Doing so allows us to be able to be more explicit in
our queries.

Let's use what we've learned to build on our original query.

Write a query that:

1.  Joins `cities` to `facts` using an `INNER JOIN`.
2.  Uses aliases for table names.
3.  Includes, in order:

-   All columns from `cities`.
-   The `name` column from `facts` aliased to `country_name`.

4.  Includes only the first 5 rows.

```{r}
query <- "SELECT c.*, f.name AS country_name FROM facts AS f
INNER JOIN cities AS c ON c.facts_id = f.id
LIMIT 5;"
# AS can be ignored
result <- dbSendQuery(conn, query)
dbFetch(result)
dbClearResult(result)
```

## Practicing Inner Joins

Let's try answering another question with inner joins. The `facts` table
contains countries, while `cities` contains some of these countries'
capitals. Using inner joins, we can create a query to return a result
that matches each capital to its respective country. Both contries and
capitals are contained in the `name` column in their respective tables,
so we'll `SELECT` them.

Now that we know what we want, we just need to join them. The tables are
still linked in the same way, so we can use the same inner join with
these columns to join the data:

```{r}
# SELECT f.name, c.name FROM cities c
# INNER JOIN facts f ON f.id = c.facts_id
```

We're not completely done, though. We're only interested in capital
cities, so we'll need a `WHERE` clause to properly filter the data. In
the `cities` table, the `capital` column is binary: `1` if the city is a
capital city and `0` otherwise. This seems like it'd be the perfect
candidate to allow us to finish our query:

```{r}
# WHERE c.capital = 1
```

We can now put this all together to write a query that answers our
question.

1.  Write a query that returns, in order:

-   A column of country names, called `country`.
-   A column of each country's capital city, called `capital_city`.

2.  Use an `INNER JOIN` to join the two tables in your query.

```{r}
query <- "SELECT f.name country, c.name capital_city FROM cities c
INNER JOIN facts f ON f.id = c.facts_id
WHERE c.capital = 1"
result <- dbSendQuery(conn, query)
dbFetch(result)
dbClearResult(result, 10)
```

## Left Joins

An inner join excludes any rows where there is not a mutual match from
both tables. We can confirm this with some simple SQL queries:

```{r}
query <- "SELECT COUNT(DISTINCT(name)) FROM facts;"
result <- dbSendQuery(conn, query)
dbFetch(result)
dbClearResult(result)
```

```{r}
query <- "SELECT COUNT(DISTINCT(facts_id)) FROM cities;"
result <- dbSendQuery(conn, query)
dbFetch(result)
dbClearResult(result)
```

These results confirm that some countries in the `facts` table don't
have corresponding rows in the `cities` table. Missing data should
always be a point of investigation for data scientists. If we wanted to
look at the cities in facts \` don't have matching cities, we would need
a different type of join to look at them --- the left join.

In addition to the rows with matches that an inner join will select, a
left join will also include rows from the first (or left) table that
don't have a match. Our Venn diagram will be handy in visualizing what
data we get back from this join.

![](https://dq-content.s3.amazonaws.com/371/venn_left.svg)\

Let's look at an example by replacing `INNER JOIN` with `LEFT JOIN` from
the first query we wrote. We've also visualized this result below, and
it's easy to see the difference that the left join creates.

```{r}
# SELECT * FROM facts
# LEFT JOIN cities ON cities.facts_id = facts.id
```

![](https://dq-content.s3.amazonaws.com/371/left_join.svg)\

For rows in `facts` that don't have a matching `fact_id` in cities, SQL
populates these empty spaces with null values, indicated by the darker
gray.

These null values can be used to filter our results in convenient ways.
If we wanted to get back to our inner join result, we could add in a
`WHERE` clause to exclude rows where any of the data from the `cities`
table is `NULL`.

```{r}
# WHERE column_name_in_cities IS NOT NULL
```

Notice that instead of using`=`to see if a value was `NULL`, we need the
keyword `IS`. Likewise, filtering for rows where the `cities` data was
`NULL` will allow us to look at the data that didn't match.

```{r}
# WHERE column_name_in_cities IS NULL
```

Let's use a left join to explore the countries that don't exist in the
`cities` table.

Write a query that returns the countries that don't exist in `cities`.

1.  Your query should return two columns:

-   The country names, with the alias `country`.
-   The country population.

2.  Use a `LEFT JOIN` to join `cities` to `facts`.
3.  Include only the countries from `facts` that don't have a
    corresponding value in `cities`.

```{r}
query <- "SELECT f.name country, f.population
FROM facts f
LEFT JOIN cities c ON c.facts_id = f.id
WHERE c.name IS NULL;"
result <- dbSendQuery(conn, query)
dbFetch(result, 10)
dbClearResult(result)
```

Right Joins and Outer Joins

There are a number of different reasons why countries may not have
corresponding values in `cities`:

-   Some countries have small populations and/or no major urban areas
    (defined as having populations of over 750,000), e.g. San Marino,
    Kosovo, and Nauru.
-   Some rows are city-states, such as Monaco and Singapore.
-   Some rows are territories that are not themselves countries, such as
    Hong Kong, Gibraltar, and the Cook Islands.
-   There are two other types of joins that you should be aware of.
    SQLite does not support these types of joins, so unfortunately you
    won't be able to practice them, but they are still important to know
    nonetheless.

The first is a right join. A right join performs the opposite operation
of a left join, and it will include all the rows of the inner join in
addition to rows in `cities` that did not have a match. We can see a
right join in the Venn diagram below:

![](https://dq-content.s3.amazonaws.com/371/venn_right.svg)\

Right joins are mainly used when you are joining more than two tables.
In these cases, using a right join is preferable because it can avoid
restructuring your whole query to join one table. Outside of this
context, right joins are rarely used. In most cases, left and inner
joins will perform the task well enough.

The other join type not supported by SQLite is a full outer join. You
can think of a full outer join as a combination of both a left and right
join. Not only will we get rows with matched IDs, we'll get the
unmatched data from both `facts` and `cities`. We can see a full outer
join in the Venn diagram below:

![](https://dq-content.s3.amazonaws.com/371/venn_full.svg)\

Like right joins, full outer joins are reasonably uncommon. Similar
results can be achieved using a union clause, which we will cover in the
next lesson. The standard SQL syntax for a full outer join is:

```{r}
# SELECT f.name country, c.name city
# FROM cities c
# FULL OUTER JOIN facts f ON f.id = c.facts_id
# LIMIT 5;
```

Let's look at the Venn diagrams of each join type side by side, which
should help you compare the differences of each of the four joins we've
discussed so far.

![](https://dq-content.s3.amazonaws.com/371/join_venn_diagram.svg)\

On the next screen, we'll practice using joins to answer some questions
about our data.

## Finding the Most Populous Capital Cities

Let's use what we've learned to produce a list of the top 10 capital
cities by population. Remember that `capital` is a boolean column
containing `1` or `0`, depending on whether a city is a capital or not.
We want the most populated capital cities, so you'll also need to sort
the results with `ORDER BY`.

Before we dive into the query, you can apply a useful shortcut to
shorten your code. Previously, we used column names to specifying how
the query results should be ordered, like so:

```{r}
# SELECT name, migration_rate FROM FACTS
# ORDER BY migration_rate DESC;
```

Instead of using the column name `migration_rate`, we could have also
indicated a number to reflect a column in the `SELECT` clause. For
example, `migration_rate` is the second column specified, so we can
write `2` in the `ORDER BY` clause instead, and it will still have the
same effect:

```{r}
# SELECT name, migration_rate FROM FACTS
# ORDER BY 2 DESC;
```

This shortcut can be used in either the `ORDER BY` or `GROUP BY`
clauses. However, in taking shortcuts, you should always be mindful of
the readability of your queries. Brevity is great in the moment, but if
we can't read our queries in the future, it loses its utility.

We won't specify which join type you should use here. Take some time to
think about the question and the query needed to answer it.

Write a query that returns the 10 capital cities with the highest
population ranked from biggest to smallest population.

Include the following columns, in order:

1.  `capital_city`, the name of the city.
2.  `country`, the name of the country the city is from.
3.  `population`, the population of the city.

```{r}
query <- "SELECT c.name capital_city, f.name country, c.population
FROM facts f
INNER JOIN cities c ON c.facts_id = f.id
WHERE c.capital = 1
ORDER BY 3 DESC
LIMIT 10;"
result <- dbSendQuery(conn, query)
dbFetch(result)
dbClearResult(result)
```

## [**Combining Joins with Subqueries**]{color="red"}

As we learned in the SQL Fundamentals course, subqueries allow us to
find the answers to more complex questions. Here, we'll learn to join on
the result of a subquery.

Here's an example of incorporating a subquery into a join and a subquery
to produce a table of countries and their capital cities.

![](https://dq-content.s3.amazonaws.com/371/explain_subquery.svg)\

Reading subqueries can be overwhelming at first, so we'll break down
what happens in this example in several steps. The important thing to
remember is that any subqueries are always calculated first and then
incorporated into the encompassing query. So, we read from the inside
out.

-   The subquery, in the red box, is calculated first. This simple query
    selects all columns from `cities`, filtering rows that are marked as
    capital `cities` by having a value for capital of 1.
-   The `INNER JOIN`joins this subquery result, aliased as `c`, to the
    `facts` table based on the `ON` clause.
-   Two columns are selected from the results of the join:
-   `f.name`, aliased as `country`.
-   `c.name`, aliased as `capital_city`.
-   The results are limited to the first 10 rows. Below is the output of
    this query:

Using this example as a model, we'll write a similar query to find the
capital cities with populations of over 10 million.

Using a join and a subquery, write a query that returns capital cities
with populations of over 10 million ordered from largest to smallest.

Include the following columns:

1.  `capital_city` - the name of the city.
2.  `country` - the name of the country the city is the capital of.
3.  `population` - the population of the city.

```{r}
query <- "SELECT c.name capital_city, f.name country, c.population population
FROM facts f
INNER JOIN (
            SELECT * FROM cities
            WHERE capital = 1
            AND population > 10000000
           ) c ON c.facts_id = f.id
ORDER BY 3 DESC;"
result <- dbSendQuery(conn, query)
dbFetch(result)
dbClearResult(result)
```

## Challenge: Complex Query with Joins and Subqueries

Let's take everything we've learned and use it to write a more complex
query. It's not uncommon to find that "thinking in SQL" takes a bit of
getting used to, so don't be discouraged if this challenge takes you a
while. It gets easier with practice!

When you're writing complex queries with joins and subqueries, it helps
to answer these questions to yourself:

-   What data do you need in your final output?
-   What tables will you need? If you need a join, how are they joined?
-   If you need to join to a subquery, what should this subquery
    accomplish? Don't be afraid to write and test your queries as you
    go. Testing queries is great for confirming that your query performs
    its job, especially if you're using a subquery.

We will be writing a query to find the countries where the urban center
(city) population is more than half of the country's total population.
Our final results will look like this.

For expected results, we rounded to six decimal places; however, when
running your query, don't worry about rounding the `urban_pct` column.

To help you out, the query you will write will include:

-   A join to a subquery.
-   A subquery to make a calculation.
-   An aggregate function.
-   A `WHERE` clause.
-   A `CAST` expression. Remember that there are multiple ways to write
    this query, and the list above is based on the approach we took in
    our solution.

Write a query that generates output as shown above. The query should
include:

1.  The following columns, in order:

-   `country`, the name of the country.
-   `urban_pop`, the sum of the population in major urban areas
    belonging to that country.
-   `total_pop`, the total population of the country.
-   `urban_pct`, the percentage of the population within urban areas,
    calculated by dividing `urban_pop` by `total_pop`.

2.  Only countries that have an `urban_pct` greater than 0.5.
3.  Rows should be sorted by `urban_pct` in ascending order.

```{r}
query <- "SELECT
    f.name country,
    c.urban_pop,
    f.population total_pop,
    (c.urban_pop / CAST(f.population AS FLOAT)) urban_pct
FROM facts f
INNER JOIN (
            SELECT
                facts_id,
                SUM(population) urban_pop
            FROM cities
            GROUP BY 1
           ) c ON c.facts_id = f.id
WHERE urban_pct > .5
ORDER BY 4 ASC;"
result <- dbSendQuery(conn, query)
dbFetch(result)
dbClearResult(result)
# disconnect with the factbook database
dbDisconnect(conn) 
```

# 2. Intermediate Joins in SQL

## Working With More Tables

In the previous lesson, we learned how to use joins to combine data from
two tables within a database. In this lesson, we'll learn more tools to
expand our capabilities to combine data from more than two tables at a
time. Most databases you'll deal with in the workplace have much more
than two tables.

We'll work with a modified version of a database called Chinook. The
Chinook database contains information about various elements in a
fictional digital music shop, such as artists, songs, and albums, as
well as the shop's employees, customers, and the customers' purchases.
All this information is contained in 11 tables.

As with our Factbook database, a schema diagram will help us understand
the available columns and the structure of the data. Here's a schema
diagram for the entire Chinook database:

![](https://dq-content.s3.amazonaws.com/372/chinook-schema.svg)\

It's a lot to take in all at once, but don't be overwhelmed! Remember
that once we start making queries, we only need to deal with one subset
of the database and its interconnections at a time. Before we look at
some specific tables, let's take a moment to understand the different
parts of the schema diagram.

-   Tables names are shown in bold, with the columns in each table
    listed below.
-   Each table has one or more columns with shading, which indicates
    those columns are a primary key. We'll learn more about primary keys
    in a later lesson, but for now, all you need to know is that each
    row's primary key must be unique.
-   Relationships between tables are shown using lines between the
    tables. The lines indicate which columns are related. You may notice
    that at least one "end" of the relationship will be a primary key.

As you work through this lesson, you may need to refer back to the
schema diagram. This is normal, so don't be bothered when that happens.
It can also be helpful to write a simple query to check the column names
and some example data from any of the tables. For instance:

```{r}
# SELECT * FROM album LIMIT 3;
```

## Joining Three Tables

```{r}
# set up connection with second database
conn2 <- dbConnect(RSQLite::SQLite(), "chinook.db")
```

First, we'll gather some information on specific purchases. For a single
purchase (denoted by `invoice_id`), we want to assemble the following
information together:

-   The ID of the track.
-   The name of the track.
-   The name of media type of the track.
-   The price that the customer paid for the track.
-   The quantity of the track that was purchased. This information is
    scattered among three tables: `invoice_line`, `track`, and
    `media_type.` To make this easier to see, an abbreviated schema
    diagram of just these three tables is shown below:

![](https://dq-content.s3.amazonaws.com/372/schema_il_t_mt.svg)\

If you didn't notice these three tables before, take a moment to explore
them in the above schema. For example, try looking at the result of the
query to become familiar with the columns and what sort of data we are
working with.

Now that you're familiar with the data, we can look at the syntax for
joining data from more than two tables.

```{r}
# SELECT [column_names] FROM [table_name_one]
# [join_type] JOIN [table_name_two] ON [join_constraint]
# [join_type] JOIN [table_name_three] ON [join_constraint];
```

If the syntax looks familiar, it should! Joining multiple tables
together simply amounts to adding multiple `JOIN` clauses onto your
query. Joins are interpreted in the order they are written, so the first
join will be executed, and then the second join will be executed against
the result of the first join. Thanks to how joins are read, we can first
build our query incrementally to ensure our results are as expected.

We will use the `invoice_line` table in our `FROM` clause since it
contains 3 of the 5 columns we want in our final query. Of course, you
can start with either of the other two, but just having most of the
columns we need already cuts down on the work. Since our tasks involves
looking for information about a specific `invoice_id`, let's choose an
`invoice_id` value of `3`. Selecting all lines from invoice_line with an
`invoice_id` is straightforward:

```{r}
# SELECT * FROM invoice_line
# WHERE invoice_id = 3;
```

Now we can use an inner join to add the data from the `track` table.

```{r}
query <- "SELECT * FROM invoice_line il
INNER JOIN track t ON t.track_id = il.track_id
WHERE invoice_id = 3;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

![](https://dq-content.s3.amazonaws.com/372/multiple_joins_step1.svg)\

Next, we add our second join to add the data from the `media_type`
table.

```{r}
query <- "SELECT * FROM invoice_line il
INNER JOIN track t ON t.track_id = il.track_id
INNER JOIN media_type mt ON mt.media_type_id = t.media_type_id
WHERE invoice_id = 3;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

![](https://dq-content.s3.amazonaws.com/372/multiple_joins_step2.svg)\

Our query has a lot of columns we don't need, so we need to alter the
SELECT clause to include only the columns we require.

Write a query that gathers data about the invoice with an `invoice_id`
of 4. Include the following columns in order:

1.  The id of the track, `track_id`.
2.  The name of the track, `track_name`.
3.  The name of media type of the track, `track_type`.
4.  The price that the customer paid for the track, `unit_price`.
5.  The quantity of the track that was purchased, `quantity`.

```{r}
query <- "SELECT
    il.track_id,
    t.name track_name,
    mt.name track_type,
    il.unit_price,
    il.quantity
FROM invoice_line il
INNER JOIN track t ON t.track_id = il.track_id
INNER JOIN media_type mt ON mt.media_type_id = t.media_type_id
WHERE il.invoice_id = 4;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

## [**Joining More Than Three Tables**]{color="red"}

Let's extend the query we wrote in the previous screen by adding the
artist for each track. If you examine the schema, you'll see that the
data for the artist's name is not directly connected to the `track`
table --- it is connected through `album` as an intermediary.

![](https://dq-content.s3.amazonaws.com/372/schema_t_al_ar.svg)\

To add in artists, we'll need to join two new tables to our existing
query:

-   `album`, which has a column common to each of the `artist` and
    `track` tables, which allows us to join those two tables.
-   `artist`, which contains the artist name data that we need. Our
    `SELECT` clause won't actually use any of the columns from the
    `album` table. When wrtiting complex queries, it's quite common to
    need to join a specific table because it will let you join to
    another table.

Add a column containing the artists name to the query from the previous
screen.

-   The column should be called `artist_name`
-   The column should be placed between track_name and `track_type`

```{r}
query <- "SELECT
    il.track_id,
    t.name track_name,
    ar.name artist_name,
    mt.name track_type,
    il.unit_price,
    il.quantity
FROM invoice_line il
INNER JOIN track t ON t.track_id = il.track_id
INNER JOIN media_type mt ON mt.media_type_id = t.media_type_id
INNER JOIN album al ON al.album_id = t.album_id
INNER JOIN artist ar on ar.artist_id = al.artist_id
WHERE il.invoice_id = 4;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

## Combining Multiple Joins with Subqueries

We are also able to join on tables created by subqueries. Let's
demonstrate this with a query that allows us to see which artists have
the most purchases in our virtual store.

The `invoice_line` table contains information on customer purchases and
the tracks they purchased. After linking these song purchases to their
respective artist, we can calculate popularity using a `GROUP BY`
clause.

With any complex query, we should first start by thinking about which
tables contain our data and which columns we need. The data we need is
in 4 separate tables: `invoice_line`, `track`, `album` and `artist`.

We could perform our query using multiple chained joins, but it could be
simpler if we had a single table containing both the track ID
(track.track_id) and the associated artist (`artist.name`). From there,
we can just join the result of our subquery to `invoice_line`. This
means our process will be:

-   Write a subquery that produces a table with both `track.track_id`
    and `artist.name`,
-   Join that subquery to the `invoice_line` table,
-   Use a `GROUP BY` statement to calculate the number of times each
    artist has had a track purchased, and find the top 10. We can write
    our subquery by joining `album` to `track` and then `artist` to
    `album`, just like we did in the previous screen. For presentational
    purposes, we'll add an `ORDER BY` and `LIMIT` to our subquery, but
    we won't need it in the final product.

```{r}
query <- "SELECT
    t.track_id,
    ar.name artist_name
FROM track t
INNER JOIN album al ON al.album_id = t.album_id
INNER JOIN artist ar ON ar.artist_id = al.artist_id
ORDER BY 1 LIMIT 5;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

Now we need to join this subquery to the `invoice_line` table. We'll
give our subquery an alias `ta` for 'track artist' to make it easier to
refer to. Again, we'll add an `ORDER BY` and `LIMIT` statement so our
output is more manageable.

```{r}
query <- "SELECT
    il.invoice_line_id,
    il.track_id,
    ta.artist_name
FROM invoice_line il
INNER JOIN (
            SELECT
                t.track_id,
                ar.name artist_name
            FROM track t
            INNER JOIN album al ON al.album_id = t.album_id
            INNER JOIN artist ar ON ar.artist_id = al.artist_id
           ) ta
           ON ta.track_id = il.track_id
ORDER BY 1 LIMIT 5;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

We only see Guns N' Roses here because the first order was for multiple
songs from this group. All that remains is for us to add our `GROUP BY`
clause, remove the extra columns, and use `ORDER BY` and LI\`MIT clauses
to select the 10 most popular artists.

```{r}
query <- "SELECT
    ta.artist_name artist,
    COUNT(*) tracks_purchased
FROM invoice_line il
INNER JOIN (
            SELECT
                t.track_id,
                ar.name artist_name
            FROM track t
            INNER JOIN album al ON al.album_id = t.album_id
            INNER JOIN artist ar ON ar.artist_id = al.artist_id
           ) ta
           ON ta.track_id = il.track_id
GROUP BY 1
ORDER BY 2 DESC LIMIT 10;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

You can use a similar technique to work out from which albums the most
songs have been purchased.

1.  Write a query that returns the top 5 albums, as calculated by the
    number of times a track from that album has been purchased. Your
    query should return the following columns, in order:

-   `album`, the title of the album
-   `artist`, the artist who produced the album
-   `tracks_purchased` the total number of tracks purchased from that
    album

2.  Your query should list the albums from most tracks purchased to
    least tracks purchased.

```{r}
query <- "SELECT
    ta.album_title album,
    ta.artist_name artist,
    COUNT(*) tracks_purchased
FROM invoice_line il
INNER JOIN (
            SELECT
                t.track_id,
                al.title album_title,
                ar.name artist_name
            FROM track t
            INNER JOIN album al ON al.album_id = t.album_id
            INNER JOIN artist ar ON ar.artist_id = al.artist_id
           ) ta
           ON ta.track_id = il.track_id
GROUP BY 1, 2
ORDER BY 3 DESC LIMIT 5;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

## Recursive Joins

In some cases, there can be a relation between two columns within the
same table. Within the `employee` table, the `reports_to` column has a
relation to the `employee_id` column within the same table.

![](https://dq-content.s3.amazonaws.com/372/recursive_joins.svg)\

The `reports_to` column identifies the employee ID of each employee's
supervisor. Since `employee_id` is the primary key for this table, we
would interpret `reports_to` as a reference to another row in the table.
If we wanted to create a report of each employee and their supervisor's
name, we would need some way of joining a table to itself. This type of
join is called a recursive join.

Syntactically, a recursive join will resemble any of the other joins
we've learned before. The only difference is that we're joining a table
to itself. We'll use aliases to distinguish between the two sides of the
join. On the left side, `e1`, we focus on the `reports_to` column since
it refers to their supervisor's ID. For the right side, the focus is on
the `employee_id` since we are trying to match the supervisors by their
own employee ID. Here's a simple example of a recursive join in action:

```{r}
query <- "SELECT
    e1.employee_id,
    e2.employee_id supervisor_id
FROM employee e1
INNER JOIN employee e2 on e1.reports_to = e2.employee_id
LIMIT 4;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

We'll add some extra columns to make our report more meaningful. Instead
of using IDs, we'll create a new column with the full name of the
employee. To combine columns, we can use the concatenate operator: `||`.
We'll concatenate the `first_name` and `last_name` columns to get the
desired full name.

You can explore how the concatenate operator works by writing a simple
query:

```{r}
# SELECT ("this" || "is" || "my" || "string");
# OUTPUT thisismystring
```

Here's a few different examples of using concatenation, this time with
columns from the `album` table:

```{r}
query <- "SELECT
    album_id,
    artist_id,
    'album id is' || album_id col_1,
    'artist id is' || artist_id col2,
    album_id || artist_id col3
FROM album LIMIT 3;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

One nice perk you may have noticed is that the SQL engine handles
converting different types where needed.

Let's use what we've learned about recursive joins and the concatenation
operator to create a report about employees and their supervisors.

1.  Write a query that returns information about each employee and their
    supervisor. Your query should return the following columns, in
    order:

-   `employee_name` - containing the `first_name` and `last_name`
    columns separated by a space, e.g. `Luke Skywalker`.
-   `employee_title` - the title of that employee.
-   `supervisor_name` - the first and last name of the person the
    employee reports to, in the same format as `employee_name`.
-   supervisor_title - the title of the person the employee reports to.

2.  The report should include employees even if they do not report to
    another employee.
3.  The report should be sorted alphabetically by the `employee_name`
    column.

```{r}
query <- "SELECT
    e1.first_name || ' ' || e1.last_name employee_name,
    e1.title employee_title,
    e2.first_name || ' ' || e2.last_name supervisor_name,
    e2.title supervisor_title
FROM employee e1
LEFT JOIN employee e2 ON e1.reports_to = e2.employee_id
ORDER BY 1;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

## Pattern Matching Using Like

Let's say you need to find some information on an employee named "Jen."
Your first instinct may be to write a query to get this information out
of the database:

```{r}
# SELECT
#     first_name,
#     last_name,
#     phone
# FROM customer
# WHERE first_name = "Jen";
```

No rows were returned by your query! The problem with filtering on
`first_name = "Jen"` is that SQL looks for an exact match. "Jen" is a
shortened version for multiple names, all equally likely: Jenny,
Jennifer, Jenna, etc. Luckily, we don't have to try to imagine every
possibility for "Jen" in our `WHERE` clause --- we have access to
another keyword that will perform the function we need. The `LIKE`
operator performs pattern matching. Instead of looking for exact matches
for "Jen," SQL will look for any instances where that name is present as
is or contained in a bigger word. The syntax for `LIKE` is as follows:

```{r}
# WHERE [column_name] LIKE "[pattern]"
```

Your pattern should be the substring you want to match for, and one or
more % characters:

-   `%Jen` - will match `Jen` at the end of a string, eg `Sarah-Jen`
-   `Jen%` - will match `Jen` at the start of a string, eg `Jenny`
-   `%Jen%` - will match `Jen` anywhere within the string, eg
    `Chris Jenner` We'll use the last pattern to give ourselves the best
    chance of a match:

```{r}
query <- "SELECT
    first_name,
    last_name,
    phone
FROM customer
WHERE first_name LIKE '%Jen%';"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

Perfect - we found one match and have Jennifer's contact information for
use later.

Keep in mind that in SQLite `LIKE` is case insensitive, so
`LIKE "%jen%"` will match `Jen` and `JEN` and `JeN`. Other flavors of
SQL may be case sensitive, so you may need to use the `LOWER()` function
to get a case insensitive match.

Let's use `LIKE` to find a different customer from our database.

You have just returned from lunch to see another phone message on your
desk: "Call Belle." Write a query that finds the contact details a
customer with a `first_name` containing `Belle` from the database.

Your query should include the following columns, in order:

-   `first_name`
-   `last_name`
-   `phone`

```{r}
query <- "SELECT
    first_name,
    last_name,
    phone
FROM customer
WHERE first_name LIKE '%belle%';"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

## Generating Columns With The Case Statement

Sometimes, you'll want to categorize your data in your query. Let's say
we wanted to generate a report summarizing each customer purchases. It
might be nice to create a column that puts each customer into a
category:

-   `small spender`: If the customer's total purchases are less than
    \$40.
-   `big spender`: If the customer's total purchases are greater than
    \$100.
-   `regular`: If the customer's total purchases are between \$40 and
    \$100 (inclusive).

To achieve this, we'll need to use the case statement. The case
statement acts like a series of if/then options for a new column. If you
know what a `switch` statement is, then `CASE` fulfills the same
function. The syntax for `CASE` is:

```{r}
# CASE
#     WHEN [comparison_1] THEN [value_1]
#     WHEN [comparison_2] THEN [value_2]
#     ELSE [value_3]
#     END
#     AS [new_column_name]
```

There can be one or more `WHEN` lines, and the `ELSE` line is optional.
If no `ELSE` line is specified, rows that don't match any `WHEN` will be
assigned a null value. Let's start by looking at a simple example. The
`media_type` table contains the name of five different media types:

```{r}
# SELECT * FROM media_type;
```

Let's look at how we can use `CASE` to add a new column `protected`,
which indicates whether each media type is protected.

```{r}
query <- "SELECT
    media_type_id,
    name,
    CASE
        WHEN name LIKE '%Protected%' THEN 1
        ELSE 0
        END
        AS protected
FROM media_type;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

In this example, our `CASE` statement has a single `WHEN` which looks
for a pattern match of the string `Protected` in the `name` column. Any
rows with a match get a value of 1, otherwise they get `0`.

Let's put `CASE` into practice using our initial scenario, where we want
to categorize customers by their purchase history.

One caveat with `CASE` is that you can't use aliases. Thus, when writing
a `CASE` statement that deals with aggregate functions, you will need to
include the aggregate function in each `WHEN` line.

1.  Write a query that summarizes the purchases of each customer. For
    the purposes of this exercise, we do not have any two customers with
    the same name.

2.  Your query should include the following columns, in order:

-   `customer_name` - containing the `first_name` and `last_name`
    columns separated by a space, e.g. `Luke Skywalker`.
-   `number_of_purchases`, counting the number of purchases made by each
    customer.
-   `total_spent` - the sum of customers total purchases made by each
    customer.
-   `customer_category` - a column that categorizes the customer based
    on their total purchases. The column should contain the following
    values:
-   `small spender` - If the customer's total purchases are less than
    \$40.
-   `big spender` - If the customer's total purchases are greater than
    \$100.
-   `regular` - If the customer's total purchases are between \$40 and
    \$100 (inclusive).

3.  Order your results by the `customer_name` column.

```{r}
query <- "SELECT
   c.first_name || ' ' || c.last_name customer_name,
   COUNT(i.invoice_id) number_of_purchases,
   SUM(i.total) total_spent,
   CASE
       WHEN sum(i.total) < 40 THEN 'small spender'
       WHEN sum(i.total) > 100 THEN 'big spender'
       ELSE 'regular'
       END
       AS customer_category
FROM invoice i
INNER JOIN customer c ON i.customer_id = c.customer_id
GROUP BY 1 ORDER BY 1;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

# 3. Building and Organizing Complex Queries

## Introduction

With the previous two lessons, we've started building up our joining
skills. We've explored joining more than three tables, joining with
subqueries and recurrent joins, but we're still just getting started.

In this lesson, we'll continue constructing complex joins, while also
learning how to:

-   Build and format your queries for readability.
-   Create named subqueries and views.
-   Combine data using set operations. Like the last lesson, we'll work
    with the Chinook database. The schema for the Chinook database is
    shown below for your convenience.

![](https://dq-content.s3.amazonaws.com/373/chinook-schema.svg)\

## Writing Readable Queries

*"Code is read much more often than it is written, so plan
accordingly.Even if you don't intend anybody else to read your code,
there's still a very good chance that somebody will have to stare at
your code and figure out what it does: That person is probably going to
be you, twelve months from now."*

---Raymond Chen

This saying is true for all programming languages, but it rings
especially true for SQL. As you incorporate subqueries and joins, your
queries will get visually complex. Investing some time in the beginning
to write your queries in a readable manner will pay dividends when your
future self and your teammates have to read your code.

One good area to address first when it comes to writing queries is the
use of capitalization and whitespace. Whitespace doesn't have any
meaning in SQL, so it can be used to help convey hierarchy in our query.
Capitalization helps us distinguish between the different clauses. To
demonstrate how important whitespace is, we'll compare the same query
written twice, one with and another without the formatting.

Here are a few tips to help make your queries more readable:

-   If a `SELECT` statement has more than one column, put each on a new
    line, indented from the `SELECT` statement.
-   Always capitalize SQL function names and keywords.
-   Put each clause of your query on a new line.
-   Use indenting and parentheses to make subqueries appear logically
    separate. Another important consideration when writing readable
    queries is the use of aliases. Aliases should be clear and concise;
    a common convention is to use the first letter of the table name. In
    cases where your complex has considerably complexity, more explicit
    aliases may be necessary.

If you work on a team, you might consider a SQL style guide that
everyone agrees to adhere to. A great guide is available at SQL style
guide. That being said, don't let rigor and consistency be a detriment
to readability. If you have a complex query and you think breaking the
style guide will make it more readable, you should do so.

As you progress through the rest of our SQL lessons, be mindful of
writing queries that are easy to read and understand. While we will
continue to check answers based on the results of the queries rather
than your formatting, practicing this will make your future colleagues
(and future self) thank you.

We'll continue our lessons on readability with named subqueries.

## The With Clause

As we saw with the previous lesson, it's often useful to create an
intermediate table with a subquery to use within a complex query.
Unfortunately, the way subqueries are written makes them harder to read;
anybody reading the query needs to find the subquery and read from the
inside-out.

One way to alleviate this is to use a `WITH` clause. `WITH` clauses
allow you to give aliases to your subqueries before the start of the
main query. The main query then refers to the subquery by its alias
name, as if it were another table in the database.

The syntax for the `WITH` clause is relatively straight-forward:

```{r}
# WITH [alias_name] AS ([subquery])
# 
# SELECT [main_query]
```

Let's look at a simple example, a query designed to gather some info
about a the tracks from a single album. First, here's a version of our
query written with a standard subquery and no `WITH` clause:

```{sql, connection = conn2, output.var = "Without"}
SELECT * FROM
    (
     SELECT
         t.name,
         ar.name artist,
         al.title album_name,
         mt.name media_type,
         g.name genre,
         t.milliseconds length_milliseconds
     FROM track t
     INNER JOIN media_type mt ON mt.media_type_id = t.media_type_id
     INNER JOIN genre g ON g.genre_id = t.genre_id
     INNER JOIN album al ON al.album_id = t.album_id
     INNER JOIN artist ar ON ar.artist_id = al.artist_id
    )
WHERE album_name = "Jagged Little Pill";
```

Anybody reading this query may have to pause while reading it. The
nested `SELECT` statements make it difficult to differentiate between
main query and subquery. By defining and naming the subquery before the
main query, the readability and intent of the main query becomes much
clearer:



```{sql, connection = conn2, output.var = "With"}
WITH track_info AS
    (
     SELECT
         t.name,
         ar.name artist,
         al.title album_name,
         mt.name media_type,
         g.name genre,
         t.milliseconds length_milliseconds
     FROM track t
     INNER JOIN media_type mt ON mt.media_type_id = t.media_type_id
     INNER JOIN genre g ON g.genre_id = t.genre_id
     INNER JOIN album al ON al.album_id = t.album_id
     INNER JOIN artist ar ON ar.artist_id = al.artist_id
    )
SELECT * FROM track_info
WHERE album_name = "Jagged Little Pill";
```


The `WITH` clause helps us better differentiate between the different
components of your query. Let's get some practice using `WITH` in a more
complex example.

Create a query that shows summary data for every playlist in the Chinook
database.

1.  Use a `WITH` clause to create a named subquery with the following
    info:

-   The unique ID for the playlist.
-   The name of the playlist.
-   The name of each track from the playlist.
-   The length of the each track in seconds.

2.  Your final table should have the following columns, in order:

-   `playlist_id` - Unique ID for the playlist.
-   `playlist_name` - Name of the playlist.
-   `number_of_tracks` - Count of the number of tracks in the playlist.
-   `length_seconds` - Sum of the length of the playlist in seconds.
    This column should be a float.

3.  The results should be sorted by `playlist_id` in ascending order.

```{r}
query <- "WITH playlist_info AS
    (
     SELECT
         p.playlist_id,
         p.name playlist_name,
         t.name track_name,
         (t.milliseconds / 1000.0) length_seconds
     FROM playlist p
     LEFT JOIN playlist_track pt ON pt.playlist_id = p.playlist_id
     LEFT JOIN track t ON t.track_id = pt.track_id
    )

SELECT
    playlist_id,
    playlist_name,
    COUNT(track_name) number_of_tracks,
    SUM(length_seconds) length_seconds
FROM playlist_info
GROUP BY 1, 2
ORDER BY 1;"
result <- dbSendQuery(conn2, query)
dbFetch(result)
dbClearResult(result)
```

## Creating Views

Sometimes, we'll need to use the same subquery in multiple different
places. Instead of writing and rewriting it, SQL has a tool that enables
us to permanently define a subquery that we can repeatedly use.

We do this by creating a view. You might think of a view as a temporary
"variable" that holds the subquery. The syntax for creating a view is:

```{r}
# CREATE VIEW [database.view_name] AS
#     SELECT * [FROM database.table];
```

We'll specify the database name using
`[database name].[view or table name]` syntax in instead of just the
view or table name itself. You'll need to use this in conjunction with
any views because we have manually attached the database. If you're
working with SQLite on your local machine or in one of our Jupyter
projects, you don't need to specify the database name like in the
following example:

```{r}
# CREATE VIEW view_name AS
#     SELECT * FROM table;
```

Here's an example of how to create a view called `customer_2`, identical
to the existing `customer` table:

```{r}
# CREATE VIEW chinook.customer_2 AS
#     SELECT * FROM chinook.customer;
```

Once the view is created, it cannot be modified or redefined. Even if we
wanted to, we'd get an error:

```{r}
# CREATE VIEW chinook.customer_2 AS
#     SELECT
#         customer_id,
#         first_name || last_name name,
#         phone,
#         email,
#         support_rep_id
#     FROM chinook.customer;
```

If we wish to redefine a view, we first have to drop the existing view
first.

```{r}
# DROP VIEW chinook.customer_2;
```

We're going to create two views that give us different versions of the
customer table. The first will be a view of all customers that live in
the USA.

```{r}
# CREATE VIEW chinook.customer_usa AS 
#      SELECT * FROM chinook.customer
#      WHERE country = "USA";
```

You can query `customer_usa` in the code editor on the right. Once a
view is created, it acts exactly like a table. Keep in mind that in our
interface, you'll have to use the syntax `[database name].[view_name]`.

Now it's your turn to create a second view of customers that have
purchased more than \$90 from our store.

1.  Create a view called `customer_gt_90_dollars`:

-   The view should contain the columns from `customers`, in their
    original order.
-   The view should contain only customers who have purchased more than
    \$90 in tracks from the store.

2.  After the SQL query that creates the view, write a second query to
    display your newly created view:
    `SELECT * FROM chinook.customer_gt_90_dollars;`.

-   Make sure you use a semicolon (;) to indicate the end of each query.
    NOTE: The query provided in the code editor is required for our
    answer checking system. Please do not delete this code.

```{r}
# DROP VIEW IF EXISTS chinook.customer_gt_90_dollars;
# CREATE VIEW chinook.customer_gt_90_dollars AS 
#     SELECT
#         c.*
#     FROM chinook.invoice i
#     INNER JOIN chinook.customer c ON i.customer_id = c.customer_id
#     GROUP BY 1
#     HAVING SUM(i.total) > 90;
# SELECT * FROM chinook.customer_gt_90_dollars;
```

## Combining Rows With Union

We have now created two views: `customer_usa` and
`customer_gt_90_dollars`. Now can we find customers who are in different
permutations of these two views:

-   Customers in the USA or have spent more than \$90
-   Customers in the USA and have spent more than \$90
-   Customers in the USA and have not spent more than \$90 Conveniently,
    our two views contain each of the above conditions, but our current
    skills won't allow us to combine them for these questions. These
    scenarios require a different type of join that to joins rows, not
    columns. Let's start by looking at just the first scenario, where we
    want to combine rows that exist in either view. To join on rows, we
    use the `UNION` operator.

![](https://dq-content.s3.amazonaws.com/373/union_vs_join.svg)\

The syntax for the union operator is composed of two or more SELECT
statements:

```{r}
# [select_statement_one]
# UNION
# [select_statement_two]
```

The `SELECT` statements before and after `UNION` must satisfy several
conditions:

-   They must contain the same number of columns, and they must be of
    compatible types.
-   These columns must also be in order.

We'll learn about types later, but just know that you can't match a
column containing text to a column with numbers.

![](https://dq-content.s3.amazonaws.com/373/union_types.svg)\

Because we created `customer_usa` and `customer_gt_90_dollars` with
identical column names, order, and type as `customer`, we can safely use
`UNION`. To answer our first scenario, the two `SELECT` statements will
be very simple - we can just select all columns and rows from each of
the two views.

Use `UNION` to produce table of customers in the USA or have spent more
than \$90, using the `customer_usa` and
`customer_gt_90_dollars views`: - The result should contain the columns
from `customers`, in their original order.

```{r}
# SELECT * from customer_usa
# 
# UNION
# 
# SELECT * from customer_gt_90_dollars;
```

## Combining Rows Using Intersect and Except

The three scenarios we discussed at the start of the previous screen
were:

-   Customers who are in the USA or have spent more than \$90
-   Customers who are in the USA and have spent more than \$90
-   Customers who are in the USA and have not spent more than \$90

The `UNION` operator enabled us to answer the first question, but what
about the other two? There are two other operators that will help us:
`INTERSECT` and `EXCEPT`. These three operators make up the set
operations in SQL. Here's a diagram and explanation of how these compare
with union.

![](https://dq-content.s3.amazonaws.com/373/set_operations.svg)\

| **Operator** | **What it Does**                                                                         | **Python Equivalent** |
|--------------|------------------------------------------------------------------------------------------|-----------------------|
| `UNION`      | Selects rows that occur in either statement.                                             | `or`                  |
| `INTERSECT`  | Selects rows that occur in both statements.                                              | `and`                 |
| `EXCEPT`     | Selects rows that occur in the first statement, but don't occur in the second statement. | `and not`             |

The syntax for both of these operations is the same as `UNION`. This
means that our second question can be answered with the following query:

```{r}
# SELECT * from customer_usa
# 
# INTERSECT
# 
# SELECT * from customer_gt_90_dollars;
```

Likewise, the third question can be answered with `EXCEPT`:

```{r}
# SELECT * from customer_usa
# 
# EXCEPT
# 
# SELECT * from customer_gt_90_dollars;
```

The results of `UNION`, `INTERSECT` and `EXCEPT` are tables, just like
everything else in SQL. As such, they can be used in subqueries and
joined to other tables for more complex analysis.

Let's look at a scenario where we'll need to join the results of a set
operation to another table:

1.  Write a query that works out how many customers that are in the USA
    and have purchased more than \$90 are assigned to each sales support
    agent. For the purposes of this exercise, no two employees have the
    same name.
2.  Your result should have the following columns, in order:

-   `employee_name` - The first_name and last_name of the employee
    separated by a space, eg `Luke Skywalker`.
-   `customers_usa_gt_90` - The number of customer assigned to that
    employee that are both from the USA and have have purchased more
    than \$90 worth of tracks.

3.  The result should include all employees with the title "Sales
    Support Agent," but not employees with any other title.
4.  Order your results by the `employee_name` column.


```{r}
# WITH customers_usa_gt_90 AS
#     (
#      SELECT * FROM customer_usa
# 
#      INTERSECT
# 
#      SELECT * FROM customer_gt_90_dollars
#     )
# 
# SELECT
#     e.first_name || " " || e.last_name employee_name,
#     COUNT(c.customer_id) customers_usa_gt_90
# FROM employee e
# LEFT JOIN customers_usa_gt_90 c ON c.support_rep_id = e.employee_id
# WHERE e.title = 'Sales Support Agent'
# GROUP BY 1 ORDER BY 1;
```


## Multiple Named Subqueries

On previous screens, we've only specified one subquery to alias. The `WITH` statement doesn't forbid us from from nicknaming multiple subqueries. To do this, just need to separate your alias/subquery pairs with a comma in the `WITH` statement.


```{r}
# WITH
#     [alias_name] AS ([subquery]),
#     [alias_name_2] AS ([subquery_2]),
#     [alias_name_3] AS ([subquery_3])
# 
# SELECT [main_query]
```



We can actually use the result of the first subquery in any of the subsequent subqueries. This can be a useful way of building readable complex queries. Below is an example of a `WITH` clause with this use case.


```{r}
# WITH
#     usa AS
#         (
#         SELECT * FROM customer
#         WHERE country = "USA"
#         ),
#     last_name_g AS
#         (
#          SELECT * FROM usa
#          WHERE last_name LIKE "G%"
#         ),
#     state_ca AS
#         (
#         SELECT * FROM last_name_g
#         WHERE state = "CA"
#         )
# 
# SELECT
#     first_name,
#     last_name,
#     country,
#     state
# FROM state_ca
```


Practically speaking, this query can be more simply written with multiple `AND` operators in our `WHERE` clause. In light of this, it's good to know how flexible a `WITH` clause can be. Let's use a more 'real life' example to gather total sales data on customers from India.



Write a query that uses multiple named subqueries in a `WITH` clause to gather total sales data on customers from India.

1. The first named subquery should return all customers that are from India.
2. The second named subquery should calculate the sum total for every customer.
3. The main query should join the two named subqueries, resulting in the following final columns:
- `customer_name` - The first_name and last_name of the customer, separated by a space, eg `Luke Skywalker`.
- `total_purchases` - The total amount spent on purchases by that customer.
4. The results should be sorted by the `customer_name` column in alphabetical order.

```{r}
# WITH
#     customers_india AS
#         (
#         SELECT * FROM customer
#         WHERE country = "India"
#         ),
#     sales_per_customer AS
#         (
#          SELECT
#              customer_id,
#              SUM(total) total
#          FROM invoice
#          GROUP BY 1
#         )
# 
# SELECT
#     ci.first_name || " " || ci.last_name customer_name,
#     spc.total total_purchases
# FROM customers_india ci
# INNER JOIN sales_per_customer spc ON ci.customer_id = spc.customer_id
# ORDER BY 1;
```

## Challenge: Each Country's Best Customer

It's time to bring everything we've learned in the course so far to write a complex query. This query will be a bit harder than anything we've written so far, so don't be discouraged if this challenge takes you a while. Write your query in steps, running it as you go to check on your results; this will make troubleshooting much easier.

We will be writing a query to find the customer from each country that has spent the most money at our store. In our database there are no "ties" for best customer in each country, and we will ignore this case for the exercise.

Our final results will look like this. For expected results, we rounded to two decimal places; however, when running your query, don't worry about rounding the `total_purchased` column.


To help you out, the query you will write will include:

- One or more named subqueries defined in a `WITH` clause.
- Aggregate functions like `SUM()` and `MAX()`.
- Several `INNER JOINs`.
- A subquery to define a column.
- `GROUP BY` and `ORDER BY` clauses.
Remember that there are multiple ways to write this query, and the list above is based on the approach we took in our solution

1. Create a query to find the customer from each country that has spent the most money at our store. Your query should return the following columns, in order:
- `country` - The name of each country that we have a customer from.
- `customer_name` - The first_name and last_name of the customer from that country with the most total purchases, separated by a space, eg `Luke Skywalker`.
- `total_purchased` - The total dollar amount that customer has purchased.
2. The rows should be order by the `country` column in alphabetical order.


```{sql, connection = conn2, output.var = "Final"}
WITH
    customer_country_purchases AS
        (
         SELECT
             i.customer_id,
             c.country,
             SUM(i.total) total_purchases
         FROM invoice i
         INNER JOIN customer c ON i.customer_id = c.customer_id
         GROUP BY 1, 2
        ),
    country_max_purchase AS
        (
         SELECT
             country,
             MAX(total_purchases) max_purchase
         FROM customer_country_purchases
         GROUP BY 1
        ),
    country_best_customer AS
        (
         SELECT
            cmp.country,
            cmp.max_purchase,
            (
             SELECT ccp.customer_id
             FROM customer_country_purchases ccp
             WHERE ccp.country = cmp.country AND cmp.max_purchase = ccp.total_purchases
            ) customer_id
         FROM country_max_purchase cmp
        )
SELECT
    cbc.country country,
    c.first_name || " " || c.last_name customer_name,
    cbc.max_purchase total_purchased
FROM customer c
INNER JOIN country_best_customer cbc ON cbc.customer_id = c.customer_id
ORDER BY 1 ASC
```

















