---
title: "2. Data Structures"
author: Ricardo
output: 
 html_document:
   toc: yes 
   toc_float: yes
   pandoc_args: ["--lua-filter=color-text.lua"]
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Font colour:** The Markdown syntax has no built-in method for changing text colors. We can use HTML and LaTeX syntax to change the formatting of words:

> Using a Pandoc Lua filter This method may be a little advanced for R users because it involves another programming language, [Lua](https://bookdown.org/yihui/rmarkdown-cookbook/font-color.html#)

```{cat, engine.opts = list(file = "color-text.lua")}
Span = function(el)
  color = el.attributes['color']
  -- if no color attribute, return unchange
  if color == nil then return el end
  
  -- transform to <span style="color: red;"></span>
  if FORMAT:match 'html' then
    -- remove color attributes
    el.attributes['color'] = nil
    -- use style attribute instead
    el.attributes['style'] = 'color: ' .. color .. ';'
    -- return full span element
    return el
  elseif FORMAT:match 'latex' then
    -- remove color attributes
    el.attributes['color'] = nil
    -- encapsulate in latex code
    table.insert(
      el.content, 1,
      pandoc.RawInline('latex', '\\textcolor{'..color..'}{')
    )
    table.insert(
      el.content,
      pandoc.RawInline('latex', '}')
    )
    -- returns only span content
    return el.content
  else
    -- for other format return unchanged
    return el
  end
end
```

To colour code the text, use the following function

> This is a test to turn banana [**yellow**]{color="green"}

# **1. Vectors in R**

## Introduction to Data Structures: Generating Vectors

-   **Vector:** one-dimensional structure for storing values of SAME TYPE.

-   **Matrix:** two-dimensional structure for storing values of SAME TYPE.

-   **Lists:** multi-dimensional structure for storing values of ANY DATA TYPE/OBJECT.

-   **Dataframe:** two-dimensional structure for storing values of ANY DATA TYPE/OBJECT.

![](https://s3.amazonaws.com/dq-content/502/datastructures.svg)

A **range of values** (i.e., consecutive values) could be generated as a vector using a colon (`:`) in R.

```{r}
1:4
```

A **sequence of values** from a value (`from`), to another value (`to`), by a step value (`by`) could be generated as a vector using the **function [`seq()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/seq.html)**

```{r}
seq(from = 2, to = 10, by = 3)
seq(from = 2, to = 10, by = 2)
```

We can also repeat a value for a specified number of times (`times`) with `rep()` function.

```{r}
rep(5, times = 4)

rep(1:3, times = 2) # repeat the vector 1, 2, 3 two times. 
```

```{r}
# create a vector that contains the value 4 repeated ten times using the rep() function
rep(4, times = 10)
# create a range of values from 1 to 12
1:12
# create a sequence of values from 2 to 5.5 by 0.25
seq(from = 2.0, to= 5.5, by =0.25)
```

## Creating a Vector Using Known Values

A vector is created using the **function `c()`**(which stands for concatenate). This function receives a **sequence of values of the SAME TYPE separated by a comma (`,`)**. R then creates the vector from those values. Here are some examples of vectors.

```{c(TRUE, FALSE, FALSE) # logical vector}
c(12L, 3L, 24L, 8L) # integer vector
c(12.10, 24.90, 4.99) # double vector
c("Monday", "Tuesday", "Wednesday","Thursday", "Friday", "Saturday","Sunday") # character vector
{r}
```

## Indexing Vectors by Position

|         Class          | Exams | Homework | Projects |          |
|:----------------------:|:-----:|:--------:|:--------:|:--------:|
|        **Math**        |  92   |    87    |    85    |   STEM   |
|     **Chemistry**      |  90   |    81    |    92    |   STEM   |
|      **Writing**       |  84   |    95    |    79    | non-STEM |
|        **Art**         |  95   |    86    |    93    | non-STEM |
|      **History**       |  77   |    85    |    90    | non-STEM |
|       **Music**        |  92   |    90    |    91    | non-STEM |
| **Physical Education** |  85   |    88    |    95    | non-STEM |

```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
is_stem_classes <- c(TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
```

![](https://s3.amazonaws.com/dq-content/502/vector_structure.svg){width="734"}

```{r}
math_grades[3] # select the third position of math_grades
exam_grades[1:4] # select the first four elements of the exam_grades
exam_grades[c(1,3,7)] # select the specific elements in position one, three, and seven of exam_grades
```

## Indexing Vectors using Logicals

```{r}
exam_grades[is_stem_classes]
```

```{r}
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
preferred_homework_grades <- homework_grades[is_stem_classes]
homework_grades
preferred_homework_grades
c("homework_grades", "preferred_homework_grades")
```

## Modifying Elements in a Vector

```{r}
# recap the previous learning
math_grades[1]
exam_grades[3:7]
exam_grades[c(2,3,6)]
exam_grades[is_stem_classes]
```

```{r}
math_grades <- c(92L, 87L, 85L)

math_grades[3] <- 90L # modify the third element of the vector

print(math_grades) # display the vector to see the changes
```

```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)

exam_grades[c(3:7)]  <-  85 # replacing all the third to seventh exam grades by 85

print(exam_grades) # display the vector to see the changes
```

```{r}
exam_grades[is_stem_classes]  <- 95 # replacing the preferred exam grades by 95 from the previous result

print(exam_grades) # display the vector to see the changes
```

## Appending Elements to a Vector

| Class                  | Exams | Homework | Projects |          |
|------------------------|-------|----------|----------|----------|
| **Math**               | 92    | 87       | 85       | STEM     |
| **Chemistry**          | 90    | 81       | 92       | STEM     |
| **Writing**            | 84    | 95       | 79       | non-STEM |
| **Art**                | 95    | 86       | 93       | non-STEM |
| **History**            | 77    | 85       | 90       | non-STEM |
| **Music**              | 92    | 90       | 91       | non-STEM |
| **Physical Education** | 85    | 88       | 95       | non-STEM |
| **Physics**            | 75    | 90       | 90       | STEM     |
| **Humanities**         | 85    | 85       | 95       | non-STEM |
| **Literature**         | 95    | 88       | 91       | non-STEM |

```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)

extra_exam_grades <- c(75, 85, 95)

new_exam_grades <- c(92, 90, 84, 95, 77, 92, 85, 75, 85, 95)

new_exam_grades <- c(extra_exam_grades, exam_grades) # to avoid tedious process, we use the this appending function, but in reversed order. 

print(new_exam_grades) # display the new vector
```

```{r}

extra_is_stem_classes  <- c(TRUE, FALSE, FALSE)
new_is_stem_classes_end <- c(is_stem_classes, extra_is_stem_classes)
new_is_stem_classes_start <- c(extra_is_stem_classes, is_stem_classes)
new_is_stem_classes_end
```

## Removing Elements from a Vector

```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
math_grades[-3]
exam_grades[-c(1, 3, 7)]
```

```{r}
math_grades <- c(92L, 87L, 85L)
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)

math_without_exam_grades <- math_grades[-1]
above_90_exam_grades <- exam_grades[c(-3, -5, -7)]

math_without_exam_grades
above_90_exam_grades
```

## Performing Operations with Vectors

```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
project_grades <- c(85, 92, 79, 93, 90, 91, 95)
math <- (92 + 87 + 85) /3
chemistry <- (90 + 81 + 92)/3 # and so on.
sum_grades <- exam_grades + homework_grades
```

![](https://s3.amazonaws.com/dq-content/502/element_wise_ops.svg)

```{r}
class_scores_sum <- exam_grades + homework_grades + project_grades

class_scores_avg <- class_scores_sum / 3

class_scores_avg

c("class_scores_sum", "class_scores_avg")
```

## Vector Recycling

What if the last homework grade is missing?

When there's a mismatch in the length of two vectors, the shorter vector is **recycled**(or repeated) until it matches the length of the longer one.

![](https://s3.amazonaws.com/dq-content/502/element_wise_ops_missing.svg)

![](https://s3.amazonaws.com/dq-content/502/element_wise_ops_missing_recycle.svg)

To see how this works in practice, see the following code block

```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
homework_grades <- c(87, 81, 95, 86, 85, 90)

exam_grades + homework_grades
```

```{r}
exam_grades <- c(92, 90, 84)
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
project_grades <- c(85, 92, 79, 93, 90, 91, 95)

class_scores_sum_recycled <- exam_grades + homework_grades + project_grades

class_scores_avg_recycled <- class_scores_sum_recycled / 3

c("class_scores_sum_recycled", "class_scores_avg_recycled")
```

## Vectors Using Names

![](https://s3.amazonaws.com/dq-content/502/named_vector_structure.svg){width="703"}

```{r}
math_grades <- c("Exams"=92L, "Homework"=87L, "Projects"=85L)

math_grades
```

```{r}
grade_names <-  c("Exams", "Homework", "Projects")
math_grades <- c(92L, 87L, 85L)

names(math_grades) <- grade_names # when the set of names already exists as a vector we can also achieve this by using the names() function.

math_grades

math_grades[c("Exams", "Projects")]

math_grades[c("Exams", "Projects")] <- 80L

math_grades
```

```{r}
exam_grades <- c(92, 90, 84, 95, 77, 92, 85)
homework_grades <- c(87, 81, 95, 86, 85, 90, 88)
project_grades <- c(85, 92, 79, 93, 90, 91, 95)

class_names <- c("math", "chemistry", "writing", "art", "history", "music", "physical_education")
# Add your code below


names(exam_grades) <- class_names
names(homework_grades) <- class_names
names(project_grades) <- class_names

exam_grades
homework_grades
project_grades
```

------------------------------------------------------------------------

# **2. Matrices in R**

## Creating a Matrix by Restructuring a Vector

A **matrix** is a **two-dimensional data structure** for storing values of **SAME TYPE**. So like vectors, matrices can be of type *logical*, *numeric* (integer and double), and *character*. Matrices being two-dimensional, introduce the notions of **rows** and **columns** whereas a vector (of one-dimension) can be indifferently considered as a column or a row.

![](https://s3.amazonaws.com/dq-content/503/matrices.svg)

A matrix is created thanks to the **function `matrix()`**. This function receives the **vector** to restructure into a matrix, and the **number of rows** (`nrow`) and **columns** (`ncol`). R is in charge of creating the matrix from the vector.

![](https://s3.amazonaws.com/dq-content/503/vector_both_matrices.gif){width="449"}

```{r}
mat_3x2_bycol <- matrix(1:6, nrow = 3, ncol = 2)

mat_3x2_bycol
```

```{r}
mat_3x2_byrow <- matrix(1:6, nrow = 3, ncol = 2, byrow = TRUE)

mat_3x2_byrow
```

```{r}
matrix(1:6, nrow = 3) # ncol = 6/nrow = 2
matrix(1:6, ncol = 2) # nrow = 6/ncol = 3
```

| A l*ogical* matrix that decides which classes are validated or not for two students (each row represents a student):

```{r}
is_validated <- c(TRUE, FALSE, FALSE, TRUE, TRUE, TRUE)
mat_is_validated <- matrix(is_validated, nrow = 2) #notice that we only specify nrow here, we also use a vector variable

print(mat_is_validated)
```

```{r}
matrix(seq(from = 2, to = 11, by = 3), nrow = 2, ncol = 2) #we use the seq() function to create our sequence of values and we don't store the result in a variable.
```

A *character* matrix that contains names of the days of a week:

```{r}
day_names <- c("Wed","Thu", "Fri", "Sat", "Sun", "Mon", "Tue")

vector_month_days <- rep(day_names, 4) # basically the vector 'day_names' for four times

matrix_month_days <- matrix(vector_month_days, nrow = 4, ncol = 7, byrow = TRUE)

print(matrix_month_days)

vector_month_days
```

```{r}
vector_1 <- c(1, 4, 5, 9) # [1] 1 4 5 9
vector_2 <- 1:12 # [1] 1  2  .. 11 12
vector_3 <- seq(from = 2.0, to = 5.50, by = 0.25) # [1] 2.00 2.25 .. 5.25 5.50
# Type your code below


matrix_1 <- matrix(vector_1, nrow = 2) # We can also set `ncol` to 2 or use both parameters
matrix_2 <- matrix(vector_2, ncol = 3) # We can also set `nrow` to 4 or use both parameters
matrix_3 <- matrix(vector_3, nrow = 3, ncol = 5, byrow = TRUE) # We set both parameters and set the `byrow` parameter to TRUE. Of course, we can also use either nrow or ncol and it will be okay.

matrix_1
matrix_2
matrix_3
```

## Creating a Matrix by Combining Vectors

| University | world_rank | quality_of_education | influence | broad_impact | patents |
|------------|------------|------------|------------|------------|------------|
| Harvard    | 1          | 1                    | 1         | 1            | 3       |
| Stanford   | 2          | 9                    | 3         | 4            | 10      |
| MIT        | 3          | 3                    | 2         | 2            | 1       |
| Cambridge  | 4          | 2                    | 6         | 13           | 48      |
| Oxford     | 5          | 7                    | 12        | 9            | 15      |
| Columbia   | 6          | 13                   | 13        | 12           | 4       |

```{r}
harvard <- c(1,1,1,1,3)
stanford <- c(2,9,3,4,10)
MIT <- c(3,3,2,2,1)
cambridge <- c(4,2,6,13,48)
oxford <- c(5,7,12,9,15)
columbia <- c(6,13,13,12,4)
```

![](https://s3.amazonaws.com/dq-content/503/vectors_to_matrix.svg)

To combine vectors into a matrix, we can use the function `rbind()`. The "r" in `rbind()` stands for rows --- this function allows us to combine multiple vectors **by row**. To demonstrate, let's combine the universities vectors using `rbind()`:

```{r}
university_matrix <- rbind(harvard, stanford, MIT, cambridge, oxford, columbia)
print(university_matrix)
```

To combine vectors into a matrix, we can also use the function `cbind()`. The "c" in `cbind()` stands for columns --- this function allows us to combine multiple vectors **by column**. The `c bind()` is used as `rbind()`.

```{r}
world_rank <- c(1, 2, 3, 4, 5, 6)
quality_of_education <- c(1, 9, 3, 2, 7, 13)
influence <- c(1, 3, 2, 6, 12, 13)
broad_impact <- c(1, 4, 2, 13, 9, 12)
patents <- c(3, 10, 1, 48, 15, 4)
# Type your code below
university_matrix <- cbind(world_rank, quality_of_education, influence, broad_impact, patents)
university_matrix
```

## Naming Matrix Rows and Columns

```{r}
university_matrix <- rbind(harvard, stanford, MIT, cambridge, oxford, columbia)

colnames(university_matrix) <- c("world_rank", "quality_of_education", "influence", "broad_impact", "patents")

university_matrix
```

```{r}
university_matrix <- cbind(world_rank, quality_of_education, influence, broad_impact, patents)
rownames(university_matrix) <- c ("harvard","stanford", "MIT", "cambridge", "oxford", "columbia")
university_matrix
```

## Indexing Matrices by Columns and Rows

![](https://s3.amazonaws.com/dq-content/503/3.4.11m503.svg)

The syntax for indexing matrices is similar to that for indexing vectors. We can extract values from the matrix by specifying their rows and/or columns in square brackets (`[]`) separated by comma(`,`).

To return the **value** in the **third row** (`MIT`) and **second column**(`quality_of_education`) of `university_matrix`, we can write:

```{r}
university_matrix[3, 2]
university_matrix["MIT", "quality_of_education"]
```

To return the **values** in the **third row** (`MIT`) of `university_matrix`, we can write:

```{r}
university_matrix[3, ] #we left the column's place empty after the comma
university_matrix["MIT", ] #we left the column's place empty after the comma
```

To return the **values** in the **second column** (`quality_of_education`) of `university_matrix`, we can write:

```{r}
university_matrix[ , 2] #we left the column's place empty before the comma
university_matrix[ , "quality_of_education"] #we left the row's place empty before the comma
```

```{r}
cell_columbia_influence <- university_matrix["columbia", "influence"]
vector_cambridge <- university_matrix["cambridge", ]
vector_world_rank <- university_matrix[, "world_rank"]
```

## Indexing Matrices using Vectors

To return the values in the first three rows (harvard, stanford, and MIT) and the second column (quality_of_education) of university_matrix, we can write:

```{r}
university_matrix[1:3, 2]
university_matrix[c("harvard", "stanford", "MIT"), "quality_of_education"]
```

To return the **rankings** for the USA's universities (i.e., Harvard, Stanford, MIT, and Columbia):

```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE) # e.g. the first TRUE means Harvard is an American university.

university_matrix[usa_universities, ] # Notice the absence of the column index
```

To return the **rankings** for the USA's universities (i.e., Harvard, Stanford, MIT, and Columbia) in the [influence, broad impact, and patents categories:]{color="red"}

```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE)

university_matrix[usa_universities, c(3, 4, 5)] # instead of  c(3, 4, 5) we can use 3:5 or the names of the columns.
```

## Modifying Elements in a Matrix

![](https://s3.amazonaws.com/dq-content/503/matrix_modif_1.svg)

To replace the value in the **third row** (`MIT`) and **second column** (`quality_of_education`) of `university_matrix` by `2`, we can write

```{r}
university_matrix[3, 2] <- 2 # modify the element at the third row and second column

# We can see that the element in the third row and the second column has changed.
```

```{r}
university_matrix[usa_universities, 3:5] <- 1 
```

![](https://s3.amazonaws.com/dq-content/503/matrix_modif_2.svg){width="448"}

```{r}
university_matrix[4,5] <- 3
university_matrix [usa_universities,1:5] <- 2
university_matrix
```

## Appending Elements To a Matrix

```{r}
tuition <- c(43280, 45000, 45016, 49350, 28450, 55161)
```

![](https://s3.amazonaws.com/dq-content/503/cbind_rbind.gif){width="704"}

```{r}
appended <- cbind(university_matrix, tuition)

appended
```

```{r}
california <- c(7, 5, 4, 7, 29, 43176)
# Type your code below
complete_university_matrix <- rbind(appended, california)
complete_university_matrix
```

## Removing Elements from a Matrix

```{r}
complete_university_matrix[-2,]
```

```{r}
usa_universities <- c(TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE)

# To remove the second and third columns from the USA universities, we can write:
complete_university_matrix[usa_universities, c(-2, -3)] 
```

```{r}
# To remove the second, third and fourth columns from complete_university_matrix where the tuition is greater than or equal to 45000, we can write:
complete_university_matrix[tuition >= 45000, c(-2, -3, -4)]
```

## Performing Operations with Matrices

```{r}
university_matrix
sum(university_matrix["harvard", -6])
sum(university_matrix["stanford", -6])
sum(university_matrix["MIT", -6])
```

![](https://s3.amazonaws.com/dq-content/503/row_col_sums.svg)

```{r}
rowSums(university_matrix)
colSums(university_matrix)
```

## Scoring and Ranking Universities

We use the **`rank()`function**, along with an expression that indexes the matrix, to specify the category we want to rank the universities by. The `rank()` function returns a vector of numeric values. For example, to rank universities by `quality_of_education`, we'd write:

```{r}
university_matrix
rank(university_matrix[,"quality_of_education"])
```

```{r}
world_rank_rank <- rank(university_matrix[,"world_rank"])
quality_of_education_rank <- rank(university_matrix[,"quality_of_education"])
influence_rank <- rank(university_matrix[,"influence"])
broad_impact_rank <- rank(university_matrix[,"broad_impact"])
patents_rank <- rank(university_matrix[,"patents"])

ranks_university_matrix <- rbind(world_rank_rank, quality_of_education_rank, influence_rank, broad_impact_rank, patents_rank)

ranks_university_matrix
```

```{r}
colSums(ranks_university_matrix)
colMeans(ranks_university_matrix)
```

# **3. Lists in R**

## Lists: Objects That Can Contain Multiple Data Types

A list, is a multi-dimensional data structure which contains MULTIPLE DATA TYPE of objects. The objects may consist of different data structures, including single data elements (literal values), vectors, matrices, and lists.

![](https://s3.amazonaws.com/dq-content/504/list.svg)

Why would we want to create lists of objects in R? The answer is that storing objects in lists allows us to make use of some very powerful R features for performing the same operation on each object in our list, which can let us avoid repetitively typing the same function.

![](https://s3.amazonaws.com/dq-content/504/mean_of_list.svg)

## Creating a List

A list is created thanks to the **function `list()`**. This function receives a **sequence of values of ANY TYPE separated by commas (`,`)**. R is in charge of creating the list from those values.

```{r}
list("tennis", "film", "outdoors")
```

```{r}
c("harvard", 1, 1, 1, 1, 3, TRUE)
```

```{r}
university_clubs <- list("ballroom dancing","rugby","bird watching", "pottery")
mit_list <- list("MIT", c(3,3,2,2,1), TRUE)
mit_named_list <- list(name = "MIT", ranking = c(3,3,2,2,1), is_in_usa = TRUE)
```

## Anatomy of a List

```{r}
club_title <- c("Chess Club")

club_description <- c("Meets two nights a week for members to play chess. Snacks are provided.")

club_dues <- c(50, 20, 15)

meeting_days <- c("Monday", "Wednesday")

meeting_times <- c("6:00 pm", "8:00 pm")
```

```{r}
club_meetings <- rbind(meeting_days,meeting_times)
club_meetings
chess_club <- list(club_title, club_description,club_dues, club_meetings)
chess_club
```

```{r}
rugby_club <- list(club_title = c("Rugby Club"), club_description = c("Plays matches against clubs from local universities"), club_dues = c(100, 50))

rugby_club
```

```{r}
# Instead of assigning a name to each element manually, we can use a vector of character data to assign names to objects of a list. Assigning names to list objects is similar to assigning names to vector elements: We'll use the names() accessor function.
ballroom_dancing <- list(c("Ballroom Dancing Club"), c("Practices waltz, salsa, and tango dancing for competitions with local university dance teams"), c(150))
ballroom_dancing
# Now, let's assign a name to each object in ballroom_dancing:
names(ballroom_dancing) <- c("club_title", "club_description", "club_dues")
```

```{r}
club_meetings <- rbind(meeting_days, meeting_times)
chess_club <- list(club_title, club_description, club_dues, club_meetings)
chess_club_names <- c("club_title", "club_description", "club_dues", "club_meetings")
names(chess_club) <- chess_club_names
chess_club
```

## Indexing Lists

We'll generally use two different indexing operations on lists: 

-   Single brackets to return a **list of selected elements** (`[]`)

-   Double brackets to return a **single element** (`[[]]`)

```{r}
rugby_club
rugby_club[2]
rugby_club[[2]]
```

```{r}
# If we check the type of the object, with the function class(), we see that it is a list:
class(rugby_club[2])
```

```{r}
rugby_club[[2]]
class(rugby_club[[2]])
```

Recall from earlier lessons that we can extract multiple elements using `c()`. Let's use single brackets to extract the first and third objects in the `rugby_club` list:

```{r}
rugby_club [c(1,3)] 
rugby_club [c(1:3)]
```

```{r}
# what happens if we use double brackets to index rugby_club?
rugby_club[[c(3,2)]]
# the output consists of the second element in the third object of the list
```

![](https://dq-content.s3.amazonaws.com/504/list_single_double_brackets.svg)

The following three lines of code extract the elements contained in the third object in the `rugby_club` list.

```{r}
# Using the symbol dollar ($) to extract elements of a named object of a list:
rugby_club$club_dues

# Using the name of the object to extract in brackets:
rugby_club[["club_dues"]]

# Using the position of the object to extract in brackets:
rugby_club[[3]]
```

```{r}
# Index the chess_club list to return the fourth object, a matrix.
meeting_matrix <- chess_club$club_meetings
meeting_matrix

# Index the third object of the chess_club list, club_dues, to return the second element of that object
club_second_due <- chess_club[[c(3,2)]]
club_second_due
```

## Modifying List Elements

```{r}
rugby_club[[3]] <- c(110, 60) # index the third object by position
rugby_club[["club_dues"]] <- c(110, 60) # index the third object by name
rugby_club$club_dues <- c(110, 60) # index the third object by name using `$`
```

```{r}
rugby_club[[c(3, 1)]] <- 60 # note that here we are indexing the first element of the third object.
rugby_club
```

```{r}
# Write code to replace the third element of club_dues to 5
chess_club[[c(3, 3)]] <- 5
# Display the third element of club_dues in the chess_club list to check that the third element of club_dues has changed
chess_club[[c(3, 3)]]
```

## Appending Elements to Lists

For the rugby club, we organized the information in the form of numeric data in a matrix named `member_years_rugby`

```{r}
fall <- c(8, 12, 13, 2)
spring <- c(6, 11, 14, 3)

member_years_rugby <- rbind(fall, spring)
colnames(member_years_rugby) <- c("first_yr", "second_yr", "third_yr", "fourth_yr")
member_years_rugby
rugby_club
```

Let's add `member_years_rugby` as a fourth object of the list. To add an element to a list, we can specify the position we want the new element to occupy using double brackets:

```{r}
rugby_club[[4]] <- member_years_rugby
rugby_club
```

Let's make three important points here:

-   The object we added is **placed at the end** of the `rugby_club` list.

-   The object is **numbered** in the list and not named since we used position indexing.

-   The object would **overwrite an existing object** if instead of specifying a new position, we specified an existing one (remember the previous screen where we modified an existing object in a list).

We could assign a name to the object as we learned earlier in this lesson. If we want to append `member_years_rugby` to `rugby_club` and give it a name, we would write:

```{r}
rugby_club[["member_years_rugby"]] <- member_years_rugby
rugby_club
```

Let's clarify the process here:

1.  The new object is **added at the end** of the list without requiring us to indicate the current end of the list (contrary to when we use positions indexing like above).

2.  A name is assigned to this object in the list.

```{r}
first_years <- c(12, 15)
names(first_years) <- c("fall", "spring")

# Add the first_years vector as an object, of the same name, to the end of the chess_club list.
chess_club[["first_years"]] <- first_years
# Index chess_club to display the number of first-year students that participated in chess club during last year's spring semester.
chess_club$first_years[[2]]
```

## Removing Elements from a List

We can remove values from a list by specifying their position preceded by a minus symbol (`-`) in square brackets (`[]`); not double square brackets. To remove the object in the second position of `chess_club`, we can write:

```{r}
chess_club

# $club_title
# [1] "Chess Club"
# 
# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."
# 
# $club_dues
# [1] 50 20  5
# 
# $club_meetings
#               [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"  
# 
# $first_years
#   fall spring 
#     12     15 

chess_club[-2]

# $club_title
# [1] "Chess Club"
# 
# $club_dues
# [1] 50 20  5
# 
# $club_meetings
#               [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"  
# 
# $first_years
#   fall spring 
#     12     15 

chess_club[c(-1, -3)]

# $club_description
# [1] "Meets two nights a week for members to play chess. Snacks are provided."
# 
# $club_meetings
#               [,1]      [,2]       
# meeting_days  "Monday"  "Wednesday"
# meeting_times "6:00 pm" "8:00 pm"  
# 
# $first_years
#   fall spring 
#     12     15 

```

```{r}
chess_club <- list("club_title" = c("Chess Club"), 
                   "club_description" = c("Meets two nights a week for members to play chess. Snacks are provided."), 
                   "club_dues" = c(50, 20, 15), 
                   "club_meetings" = rbind(c("Monday", "Wednesday"),  c("6:00 pm", "8:00 pm")),
                   "first_years" = c("fall" = 12, "spring" = 15))

# Write code to remove the first object of the list, chess_club.
chess_club_without_1 <- chess_club[-1]

# Write code to remove the object at the third and fourth positions of the chess_club list.
chess_club_without_34 <- chess_club[c(-3, -4)]

chess_club
chess_club_without_1
chess_club_without_34
```

## Combining Lists

Syntax for combining multiple lists is similar to combining vectors. To combine the `rugby_club` and `ballroom_dancing` lists into a new list called `university_club_data`, we can use the `c()`function:

```{r}
university_club_data <- c(rugby_club, ballroom_dancing)
university_club_data
```

The `university_club_data` list is confusing because some of the elements, like `club_description`, have the same name. We need a way to combine lists that preserve the organization of each list.

```{r}
# Recall that lists can contain any type of data object, including other lists. Instead of combining elements of the three lists into a single list as we did using c(), we can use list() to create a new list of lists. 
university_club_list <- list(rugby_club = rugby_club, ballroom_dancing = ballroom_dancing)
university_club_list
```

```{r}
university_clubs <- list(rugby_club = rugby_club, ballroom_dancing = ballroom_dancing, chess_club = chess_club)
university_clubs
```

# **4. Dataframes in R**

Throughout this course, we've learned about different data structures available to us in R. Matrices and their use for storing numbers in an organized structure, and how lists are useful for keeping data of different types together in the same data structure. As we approach the end of this course, we'll explore an essential data structure for analysis. In this lesson, we'll learn how to deal with **tabular data**.

Tabular data is data organized into rows. If you've ever worked with data from Microsoft Excel, Google Sheets or a humble comma separated value file (CSV), then you've already been exposed to some form of tabular data. In tabular data, a single row represents information on a single thing or entity. This information is divided up into distinct columns. As we stack rows together, we get a rectangle of data, or table, that gives tabular data its name. Graphically, tabular data looks like:

![](https://dq-content.s3.amazonaws.com/493/tabular-data.png)

The `tidyverse` packages have created a special data structure to represent tabular data called a **tibble**. If you've worked with base R before, tibbles are like data frames, but with added functionality that makes them easier to work with. The difference between a tibble and a data frame is that tibbles are compatible with all of the packages associated with the `tidyverse`. As we'll learn more throughout this lesson, we can create elegant and easy-to-read R code using tibbles and the `tidyverse`. Tibbles help streamline the process of data analysis and make you an even more effective R programmer.

## Getting Familiar With The Data

In our Introduction to R course, we learned about the **`read_csv()` function** from the `readr` package, which allows us to read in CSV files into our R session. Assuming that the name of the dataset was `recent_grads.csv` and that it was in our working directory, we can read the data into a variable `recent_grads` using the following code:

```{r}
library(readr)
library(tidyverse)
library(tibble)
recent_grads <- read_csv("recent_grads.csv")
```

The first thing any data analyst should do before doing any sort of analysis is become familiar with the data. This involves many things, but we should be focused on knowing the following things first:

1.  What are the column names of the data?

2.  What are the data types of each column?

3.  How many rows are in the data? Columns?

There are many ways that we can get the answers to these questions, but we'll explore a few different methods. If we just wanted to get a quick summary of the data itself, we can use the **`glimpse()` function** from the `tibble` library. The **`glimpse()`function** will help answer all three of the above questions for us. We show a truncated version of the function output below.

```{r}
glimpse(recent_grads)
```

The number of "Observations" corresponds to the number of rows in the dataset, while the number of "Variables" tells us the number of columns. After these numbers, we see each of the variables/columns in more detail, including the column name, its type and a small sample of the values contained in the column. For example, the [`Rank` column is the first column in the data and contains numbers in the form of doubles (`dbl`)]{color="red"}. Since each row represents a major, the `Rank` column represents the ranking of each major. Knowing the column names and types is important because it allows us to filter and choose subsets of the data.

One weakness of the **`glimpse()` function** is that it's purely for reading. There are times where we might actually need the number of rows or columns to store in a variable. If we want to do this, we would need to use the `nrow()` or `ncol()` functions, respectively. Both of these functions can take in a tibble and they output the number of rows/columns.

```{r}
nrow(recent_grads) # returns the number of rows in `data`
ncol(recent_grads) # returns the number of columns in `data` 
```

## Selecting Columns

To filter the data by columns, we can use the **`select()` function** which comes from the `dplyr` library. Notice that this is also a `tidyverse` library. The **`select()` function** actually takes a variable number of arguments since it doesn't know ahead of time how many columns a programmer may need from it. The first argument that the **`select()`function** takes is a tibble, and the following arguments are column names that are in the tibble. An example follows using the `recent_grads` dataset:

```{r}
filtered_data <- select(recent_grads, Rank, Major)
```

The above code took in the `recent_grads` tibble and used the `select()` function to pick out two columns from it, `Rank and Major`. The filtered data is then assigned to the variable `filtered_data`. We can specify as many columns as we want to keep in the `select()` function, as long as they are actually present in the tibble.

The `select()` function can also be used to *remove* columns from a dataset. The syntax is similar to keeping columns, with a minor tweak. The code below removes one column from the data:

```{r}
filtered_data <- select(recent_grads, -College_jobs)
filtered_data
```

## Filtering Rows

Recall that each of the rows represents information on a single thing (or in this case, major), so filtering the rows means looking for a subset of the rows that have a particular quality. We want to filter rows using the `filter()` function.

Like the `select()` function, the `filter()` function first takes in a dataset, followed by conditions on columns that we want to use to filter. Below is an example use of the `filter()` function on the `recent_grads` data.

```{r}
top_100_majors <- filter(recent_grads, Rank < 100)
# If we had multiple conditions, then we would separate them using commas:
large_engineering_majors <- filter(recent_grads, 
                                   Total > 5000, 
                                   Major_category == "Engineering")
```

Notice too that we've broken up the function into different lines, based on the commas. We could still have everything on one line, but it's good practice to keep one line from getting too long. We can clearly differentiate between the different conditions, which makes for more readable code.

-   `column == a`: equality, "Filter for where the column equals 'a'"\
-   `column != b`: not equals, "Filter for where the column is not 'b'"\
-   `column < 5`: less than, "Filter for where the column is less than 5"\
-   `column <= 5`: less than or equal, "Filter for where the column is less than or equal to 5"\
-   `column >= 10`: greater than or equal, "Filter for where the column is greater than or equal to 10"

```{r}
# Filter the recent_grads data for those with a Sample_size value greater than 100. Assign this filtered tibble to the variable large_sample_majors.
large_sample_majors <- filter(recent_grads, 
                              recent_grads$Sample_size > 100)
# Filter the recent_grads data:
# Where Total is less than or equal to 70,000
# Where Median is greater than 40,000
# Where the Major_category isn't Engineering

non_engineering_majors <- filter(recent_grads,
                                 Total <= 70000,
                                 Median > 40000,
                                 recent_grads$Major_category != "Engineering")
```

## Piping With The %\>% Operator

[Shortcuts for pipe operator **%\>%** : Shift + Command + M]{color="red"}\
[Shortcuts for text transformation **\#**: Shift + Command + C]{color="blue"}

Let's say that we want to filter both rows and columns, which means we want to use both the `select()` function and `filter()` functions. We might write this code out like this:

```{r}
ranked_majors <- select(recent_grads, Rank, Major, Total)
low_total_ranked_majors <- filter(ranked_majors, Total < 2000)
```

There's nothing wrong with this approach, but imagine a scenario where there are multiple data manipulation steps we need to take. Each step creates a new tibble, assign it to a new variable and then pass this variable into a new function. This creates a situation where we're creating a lot of tibbles that are just used once, and we have to keep track of all these new variables.

The `tidyverse` provides us with a beautiful tool that will allow us to streamline this process and do all of our data manipulation in one place. That tool is the `%>%` function, named the pipe operator. The pipe operator allows us to take the output of one function and have it be used directly as the input of another function. In terms of code, we can rewrite the above using `%>%`:

```{r}
low_total_ranked_majors <- recent_grads %>%
  select(Rank, Major, Total) %>%
  filter(Total < 2000)
```

The two code blocks produce exactly the same result, but the `%>%` operator allows us to better see the flow of our data manipulation. In the first line of the new code, the `recent_grads` tibble is piped into the `select()` function. Similarly, the output of `select()` is passed into the `filter()` function, where the pipeline ends.

Using `%>%`, we only need to create one new variable, and we are able to have our entire data manipulation pipeline into one place. This is extremely powerful for code readability and simplification. Less variables means less room for errors down the line, and more readable code means less time spent trying to understand what it's trying to do. We encourage you to use piping as you learn more about R and the `tidyverse`.

The code we've used so far uses `%>%` in the context of tibbles, but we can use it with any data structures of variables that we have in R! We'll demonstrate this below:

```{r}
# Old way of summing a vector
sum(c(1, 2, 3, 4, 5))

# "Piping" the vector into the sum function
c(1, 2, 3, 4, 5) %>% sum()


# Old way of printing a string in the R console
print("Learning about the pipe!")

# "Piping" a string into the print function
"Learning about the pipe!" %>% print

```

```{r}
recent_grads
# Removes the Rank and Major columns and Filters for majors with a Median pay less than 50000
pipeline_output <- recent_grads %>% select(-Rank, -Major) %>% filter(Median < 50000)
```

## Creating New Columns

Now that we know how to filter our tibbles down based on row or column, we can move onto a new method of manipulating our data. Once we've filtered our data down to what we need, the next step is often to create new columns from the existing data.

**One common example of creating new data from existing columns is converting counts into percentages**. In the `recent_grads` data, we have a Total column and a `Men` column. `Total` indicates the number of people surveyed with the major, while `Men` indicates how many of these people are male. These numbers by themselves don't tell us much since the `Totals` vary so much, but if we create a new column based on percentages, this will allow us to better compare majors.

In order to create a new column based on other columns, we need to use the `mutate()` function. Within a `mutate()` function, we name new columns and define how they should be calculated. For example, we can do the following:

```{r}
new_recent_grads <- recent_grads %>%
  mutate(
    prop_male = Men / Total,
    prop_male_gt_half = prop_male > 0.5
  )
```

The result of the code is another new tibble `new_recent_grads` that contains all of the data that `recent_grads` has, with two additional `columns prop_male` and `prop_male_gt_half`. The `mutate()` function is what creates both of these new columns.

To make the `prop_male column`, the `mutate()` function takes the Men value and divides it by the Total value for each row. It does this for each row and assembles `prop_male` with all these values.

The second new column `prop_male_gt_half` gets constructed in a similar manner, but it actually uses prop_male. We're allowed to reference new columns in the `mutate()` function, which is what makes it so powerful. All of the rows in `prop_male` are compared to the value 0.5. If they're greater, `prop_male_gt_half` will be TRUE and FALSE otherwise.

```{r}
new_recent_grads <- recent_grads %>% mutate(prop_employed = recent_grads$Employed/recent_grads$Total,
                                            prop_women= recent_grads$Women/recent_grads$Total,
                                            prop_women_gt_employed = prop_women > prop_employed)
```

## Sorting Data

After creating columns of interest, it's good practice to reexamine the data to see if it matches your expectations. Sometimes mistakes will be made in calculations, and it's better to catch them early.

Let's say that we're not sure if the `prop_male` column we calculated came out correctly. We would expect the higher values of prop_male to have either high numbers of `Men`, low `Total` or both. To examine this, we need to sort the data based on the `prop_male` column in descending order and examine the first few values.

[The `arrange()` function can help us with that.]{color="red"} This function takes in one or more columns that we want to sort the tibble by. Taking the example from the last screen, we can sort by `prop_male` by doing the following:

```{r}
new_recent_grads <- recent_grads %>%
  mutate(
    prop_male = Men / Total
  ) %>% 
  arrange(-prop_male) %>% 
  select(Total, Men, prop_male)
```

By default, the `arrange()` function sorts things into ascending order. If we were just to supply `prop_male` by itself to `arrange()`, then the tibble would start with the row with the smallest value. To reverse this, we just need to add a - sign to the beginning to indicate sorting in descending order.

If we supply multiple columns into the `arrange()` function, then the data will be sorted from left to right. That is to say, after sorting on the first column, the `arrange()` function will perform subsorts based on the columns that come after it.

Now we can have a quick look at `new_recent_grads` to prove to ourselves that the calculation was correct. Using the `head()` function, we can have a look at the first few rows:

```{r}
head(new_recent_grads)
```

```{r}
# What major has the lowest proportion of employed graduates?
least_employed <- recent_grads %>%
  mutate(
    prop_employed = Employed / Total
  ) %>% 
  arrange(prop_employed) %>% 
  select(Major, Employed, Total, prop_employed)
    
head(least_employed)
```

## Summarizing Data

In the last screen, we inspected a tibble visually after doing some sorting. While visual inspection is useful in a lot of situations, it's better used for quick glances and checks.

In other cases, we'll want to gather some summary statistics to get a better understanding of our data. Instead of calculating these by hand, we can use the `summarize()` function to get these values with a short line of code. For example, if we want to see what the average unemployment rate was across the majors.

A common theme among the functions we've learned in this lesson is that they all produce tibbles, and the same applies to the `summarize()` function. Inspecting `summary_table` in the console produces.

```{r}
summary_table <- recent_grads %>% 
  summarize(
    avg_unemp = mean(Unemployment_rate),
    min_unemp = min(Unemployment_rate),
    max_unemp = max(Unemployment_rate)
  )
summary_table
```

The `summarize()` function is often combined with the `group_by()` function which allows splitting the dataframe into several subsets on which we can apply functions. This workflow is known as split-apply-combine workflow. It is widely used in data analysis. It consists in three steps:

1.  Split the dataset into subsets using the function `group_by()`.\
2.  Apply functions to those subsets using the `summarize()` function.\
3.  Combine the results back together using again the `summarize()` function.\

In the above example, we can introduce the `group_by()` function to summarize the dataframe by `Major_category`.

```{r}
summary_by_Major_category <- recent_grads %>% 
  group_by(Major_category) %>%
  summarize(
    avg_unemp = mean(Unemployment_rate),
    min_unemp = min(Unemployment_rate),
    max_unemp = max(Unemployment_rate)
  )
# We can display the first three rows of summary_by_Major_category using

head(summary_by_Major_category, 5)

```

```{r}
# Create a new tibble called minmax_median_income that calculates the minimum and maximum value in the Median column.
minmax_median_income <- recent_grads %>% 
  summarize(
    min_income = min(Median),
    max_income = max(Median)
  )
# Create a new tibble called minmax_median_income_by_major that calculates the minimum and maximum value in the Median column grouping by the Major column.
minmax_median_income_by_major <- recent_grads %>% 
  group_by(Major) %>%
  summarize(
    min_income = min(Median),
    max_income = max(Median)
  )
```

## Using Tibble Columns As Vectors

As we wrap up this lesson, we'll cover one last function that will prove useful in your data analysis tasks. There are times where we'll want to isolate a column from a tibble and use it as a vector so that we can perform some calculations on it. There are 3 ways to do this, one of which we will recommend over the others.

Storing a tibble column as a vector lets us do calculations on it as we would any other vector. Examples include summing up all the values in a vector or taking their average. We'll use taking the sum as an example throughout this screen.

The first way we can use a column as a vector is through `$` (read as "dollar sign") notation. The syntax for this is `[tibble]$[column_name]`, and we'll use it to get the `Sample_size` column from the `recent_grads` tibble:

```{r}
sample_sizes <- recent_grads$Sample_size
sample_sizes %>% sum
```

We use `$` notation to "pull" the `Sample_size` column from `recent_grads` and store it into the sample_sizes variable. By using `$` notation, `sample_sizes` acts as a vector, so we can pipe it into the `sum()` function. We could have also just coded it as `recent_grads$Sample_size %>% sum`, but we wanted to show that these results can be stored into variables as well.

The second way we can use a column as a vector is through double-bracket notation. The syntax for this is `[tibble][["column_name"]]`. This method is useful if your data happens to have columns that have white space in it. If there's white space in a column name, then we are unable to use the `$` notation.

```{r}
sample_sizes <- recent_grads[["Sample_size"]]
sample_sizes %>% sum
```

Notice that the column name must be contained in quotes. This is what allows the double-bracket method to account for columns with whitespace in it.

The final way that we can use a tibble column as a vector is through the `pull()` function. This is the way we recommend that you use columns as vectors from here on out.

```{r}
sample_sizes <- recent_grads %>% pull(Sample_size)
sample_sizes %>% sum
```

We recommend using the `pull()` function over \$ or double-bracket notation because it flows better with the `%>%` operator and increases readability. Get some practice using the pull() function before you wrap up this lesson.

```{r}

# Using the pull() function, take the Median column from recent_grads dataset and assign it to the variable medians.
medians <- recent_grads %>% pull(Median)

# Using the max() function, find the highest value that is present in the medians variable and assign it to the variable highest_median.
highest_median <- medians %>% max
```
